# Copyright 2016. F5 Networks, Inc. See End User License Agreement (EULA) for
# license terms. Notwithstanding anything to the contrary in the EULA, Licensee
# may copy and modify this software product for its internal business purposes.
# Further, Licensee may upload, publish and distribute the modified version of
# the software product on devcentral.f5.com.

cli script f5.iapp.1.5.1.cli {
 
#  Initialization proc for all templates.
#  Parameters "start" and "stop" or "end".
proc iapp_template { action } {
    switch $action {
        start {
            catch { tmsh::modify sys scriptd log-level debug }
            set ::clock_clicks [clock clicks]
            puts "\nStarting iApp $tmsh::app_template_name [clock format \
                [clock seconds] -format {%m/%d/%Y %T}]\n"
            tmsh::log info "Starting iApp template $tmsh::app_template_name"
        }
        stop -
        end {
            if { [info exists ::substa_debug] } {
                puts $::substa_debug
            }
            puts "\nEnding iApp $tmsh::app_template_name [clock format \
                [clock seconds] -format {%m/%d/%Y %T}]\nRun time [expr \
                { ([clock clicks] - $::clock_clicks) / 1000 }] msec\n"
            tmsh::log info "Ending iApp template $tmsh::app_template_name"
        }
    }
    set ::HTTP_CONTENT_TYPES { application/(css\|css-stylesheet\|doc\|excel\|javascript\|json\|lotus123\|mdb\|mpp\|msaccess\|msexcel\|ms-excel\|mspowerpoint\|ms-powerpoint\|msproject\|msword\|ms-word\|photoshop\|postscript\|powerpoint\|ps\|psd\|quarkexpress\|rtf\|txt\|visio\|vnd\\.excel\|vnd\\.msaccess\|vnd\\.ms-access\|vnd\\.msexcel\|vnd\\.ms-excel\|vnd\\.mspowerpoint\|vnd\\.ms-powerpoint\|vnd\\.ms-pps\|vnd\\.ms-project\|vnd\\.msword\|vnd\\.ms-word\|vnd\\.ms-works\|vnd\\.ms-works-db\|vnd\\.powerpoint\|vnd\\.visio\|vnd\\.wap\\.cmlscriptc\|vnd\\.wap\\.wmlc\|vnd\\.wap\\.xhtml\\+xml\|vnd\\.word\|vsd\|winword\|wks\|word\|x-excel\|xhtml\\+xml\|x-java-jnlp-file\|x-javascript\|x-json\|x-lotus123\|xls\|x-mdb\|xml\|x-mscardfile\|x-msclip\|x-msexcel\|x-ms-excel\|x-mspowerpoint\|x-msproject\|x-ms-project\|x-msword\|x-msworks-db\|x-msworks-wps\|x-photoshop\|x-postscript\|x-powerpoint\|x-ps\|x-quark-express\|x-rtf\|x-vermeer-rpc\|x-visio\|x-vsd\|x-wks\|x-word\|x-xls\|x-xml) image/(photoshop\|psd\|x-photoshop\|x-vsd) text/(css\|html\|javascript\|json\|plain\|postscript\|richtext\|rtf\|vnd\\.wap\\.wml\|vnd\\.wap\\.wmlscript\|wap\|wml\|x-component\|xml\|x-vcalendar\|x-vcard) }
}

proc iapp_is { args } {
    set up_var [lindex $args 0]
    upvar $up_var var
    if { [info exists var] } {
        foreach val [lrange $args 1 end] {
            if { [subst $var] eq $val } {
                return 1
            }
        }
    }
    return 0
}

proc iapp_substa { args } {
    upvar substa_in  argx \
          substa_out rval
    set   argx $args

    # check the explicit value first.
    # multiple layers of variable substitution requires multiple subst.
    # error occurs here if any of the substituted variables do not exist
    # valid wildcard (*) array entries will fail here first.
    uplevel {
        append ::substa_debug "\n$substa_in"
        if { [info exists [set substa_in]] } {
            set substa_out [subst $$substa_in]
            set substa_out [subst $substa_out]
        } else {
            # since explicit value did not exist, try a wildcard value.
            # substitute "*" as the array key and repeat.
            set substa_tmp [split $substa_in "()"]
            set substa_in "[lindex $substa_tmp 0](*)"
            append ::substa_debug "*"
            if { [info exists [set substa_in]] } {
                set substa_out [subst $$substa_in]
                set substa_out [subst $substa_out]
            } else {
                error "substa \"$substa_in\" array value not found"
            }
        }
    }
    return $rval
}

proc iapp_conf { args } {

    # Return value $object_name is set to the first word in $arg that
    # contains an underscore, since the position of the object name in
    # tmsh syntax is not consistent.
    set args [join $args]
    set object_name [lindex $args [lsearch -glob $args "*_*"]]

    # Global array ::tmsh_history persists between calls to iapp_conf
    # in order to suppress duplicate commands.
    if { ![info exists ::tmsh_history($args)] } {
        set ::tmsh_history($args) 1
        iapp_debug $args
        switch -exact -- [string range $args 0 5] {
            create { tmsh::create [string range $args 7 end] }
            modify { tmsh::modify [string range $args 7 end] }
            delete { tmsh::delete [string range $args 7 end] }
            default { error "iapp_conf illegal parameter" }
        }
    }
    return $object_name
}

proc iapp_make_safe_password { password } {
    return [string map { \' \\\' \" \\\" \{ \\\{ \} \\\} \; \\\; \| \\\| \# \\\# \  \\\  \\ \\\\ } $password]
}

proc iapp_pull { loc items_list } {
    upvar $items_list items
    if { [set item [lindex $items $loc]] != "" } {
        set items [lreplace $items $loc $loc]
    }
    return $item
}

proc iapp_process_flags { flags_array args_list } {
    upvar $flags_array flags
    upvar $args_list args

    if { [set dubdash [lsearch $args "--"]] != -1 } {
        set args [lreplace $args $dubdash $dubdash];
    } else {
        set dubdash end
    }

    foreach flag [array names flags] {
        while { [set ptr [lsearch [lrange $args 0 $dubdash] $flag]] != -1 } {
            set args [lreplace $args $ptr $ptr];

            # we want to run the code in the flags_array at the calling
            # proc's level so that the variables that it sets up are
            # available there.
            set access_var [format "$%s(%s)" $flags_array $flag]
            set command [subst -nocommands { set ptr $ptr ; subst $access_var }]

            uplevel 1 $command
        }
    }
    return $args
}

proc iapp_tmos_version { args } {
    set cversion [tmsh::version]
    if { $cversion eq "" } {
        tmsh::log err "unable to determine TMOS version"
        error "unable to determine TMOS version"
    }

    # if no op+version was specified, just return the version
    if { $args eq "" } { return $cversion }
    if { [llength $args] > 2 } {
        error "Too many arguments"
    }

    set op [lindex $args 0]; # operator
    set NOTFOUND -1
    # constrain to valid operators - adding more is fine as long as
    # they are supported by [expr] (and makes sense)
    if { [lsearch -exact { < > <= >= == != } $op] == $NOTFOUND } {
        tmsh::log err "illegal operator: $op"
        error "illegal operator: $op"
    }

    set tversion [lindex $args 1]; # target version
    # one or two decimal digits, optionally followed by 0-2 complete groups of
    # dots followed by one or two decimal digits with nothing before or after
    set regex {^\d{1,2}(\.\d{1,2}){0,2}$}
    if { ! [regexp -- $regex $tversion] } {
        tmsh::log err "cannot parse version from: $tversion"
        error "cannot parse version from: $tversion"
    }

    # p=>prefix, c=>current, t=>target
    foreach p { c t } {
        # extract major/minor/point components
        scan [set [set p]version] "%d.%d.%d" [set p]mjr [set p]mnr [set p]pnt
        # ensure that these are each set to at least 0
        foreach level { mjr mnr pnt } {
            if { ! [info exists [set p]${level}] } { set [set p]${level} 0 }
        }
        # turn them into one big number that we can compare
        # leave room in-between just to be safe
        set [set p]num [expr {
            [set [set p]mjr]*1000000 +
            [set [set p]mnr]*10000 +
            [set [set p]pnt]*100
        }]
    }
    # a simple numeric comparison is all that is needed at this point
    return [eval expr $cnum $op $tnum ]
}

proc iapp_safe_display { args } {
    # strings sent to APL must be truncated to 65535 bytes, see BZ435592
    if { [string length [set [set args]]] > 65535 } {
        set last_newline [string last "\n" [set [set args]] 65500]
        return "[string range [set [set args]] 0 $last_newline]Error: Too many items for display"
    } else {
        return [set [set args]]
    }
}

proc iapp_get_items { args } {

    # Set default values.
    set error_msg  "iapp_get_items $args:"
    set do_binary  0
    set nocomplain 0
    set items      ""
    set join_char  "\n"
    set recursive  "recursive"
    set com_dir    "/Common"
    set loc_dir    "[tmsh::pwd]"

    # Set up flag-related work.
    array set flags  {
        -exists      { [set do_binary 1] }
        -nocomplain  { [set nocomplain 1] }
        -list        { [set join_char " "] }
        -norecursive { [set recursive ""] }
        -local       { [set com_dir   ""] }
        -dir         { [set loc_dir      [iapp_pull $ptr args]] }
        -filter      { [set filter_field [iapp_pull $ptr args]] \
                       [set filter_op    [iapp_pull $ptr args]] \
                       [set filter_value [iapp_pull $ptr args]] }
    }
    iapp_process_flags flags args

    # Get system object names in all requested directories.
    set save_dir [tmsh::pwd]
    foreach dir [lsort -unique "$com_dir $loc_dir"] {
        tmsh::cd $dir
        set tmsh_rval [catch {
            foreach obj [tmsh::get_config $args $recursive] {

                if { [info exists filter_field] } {
                    if { $filter_field eq "NAME" } {
                        set val [tmsh::get_name $obj]
                    } else {
                        # If get_field_value throws error, assume "none" value
                        if { [catch {
                            set val [tmsh::get_field_value $obj $filter_field]
                            # strip quotes per BZ442531
                            set val [string map {\" ""} $val]
                        }]} { set val none }
                    }
                    # Non-Tcl operators =~ and !~ added for extra flexibility
                    if { $filter_op eq "=~" } {
                        set filter "\[regexp \"$filter_value\" \"$val\"\]"
                    } elseif { $filter_op eq "!~" } {
                        set filter "!\[regexp \"$filter_value\" \"$val\"\]"
                    } else {
                        set filter "\\\"$val\\\" $filter_op \\\"$filter_value\\\""
                    }
                    # If filter fails, skip to next object
                    if { ![eval expr $filter] } {
                        continue
                    }
                }
                # string map catches /Common added by ltm profile ntlm,
                # which is unlike all other ltm profile return values.
                lappend items $dir/[string map {/Common/ ""} [tmsh::get_name $obj]]
            }
        } err ]
    }
    tmsh::cd $save_dir

    # array keys: $do_binary,$tmsh_rval,$nocomplain. Do not insert whitespace.
    array set rval {
        0,0,0 {[join $items $join_char]}
        0,0,1 {[join $items $join_char]}
        0,1,0 {[error "$error_msg $err"]}
        0,1,1 {}
        1,0,0 {[llength $items]}
        1,0,1 {[llength $items]}
        1,1,0 {0}
        1,1,1 {0}
    }

    return [subst $rval($do_binary,$tmsh_rval,$nocomplain)]
}

proc iapp_get_provisioned { args } {

    array set lnum {
        none      0
        minimum   1
        nominal   2
        dedicated 3
    }

    # Set defaults.
    set required minimum
    set do_binary 1

    # Set up flag-related work.
    array set flags  {
        -is          { [set required [iapp_pull $ptr args]] }
        -level       { [set do_binary 0] }
    }
    iapp_process_flags flags args
    if { [llength $args] > 1 } {
        error "Too many arguments"
    }

    # If checking for AM provisioning on TMOS < 11.4,
    # check for WAM provisioning instead.
    if { $args eq "am" && [iapp_tmos_version < 11.4] } {
        set args "wam"
    }

    # Get the provisioning level. If blank, assume none.
    # Proc only checks 1 module at a time, so only 1 object is returned.
    if { [catch {
        set obj [tmsh::get_config sys provision $args]
        set level [tmsh::get_field_value [lindex $obj 0] level]
    }]} { set level none }

    if { $do_binary } {
        return [expr { $lnum($level) >= $lnum($required) }]
    } else {
        return $level
    }
}

proc iapp_get_user { args } {

    # Set defaults.
    set do_role 0
    set do_binary 0

    # Set up flag-related work.
    array set flags  {
        -is_admin    { [set do_binary 1] }
    }
    iapp_process_flags flags args
    if { [llength $args] > 1 } {
        error "Too many arguments"
    }

    # Show user auth was introduced in v11.6
    set user "unknown"
    catch {
        set user [tmsh::show auth user field-fmt]
    } err
    if { $do_binary } {
        return [expr { $user == "unknown"
        || [string first "role " $user] == -1
        || [string first "role admin" $user] != -1
        || [string first "role resource-admin" $user] != -1 }]
    } else {
        return $user
    }
}

proc iapp_destination { args } {
    # Set defaults. Flag actions may overwrite defaults later.
    set route_domain    0
    set do_mask         0
    set port            0

    # Set up flag-based actions.
    array set flags  {
        -route_domain { [set route_domain [iapp_pull $ptr args]] }
        -mask         { [set do_mask 1] }
        -length       { [set cidr_bits [iapp_pull $ptr args]] }
    }

    if { [llength [set non_switches [iapp_process_flags flags args]]] > 2 } {
        error "Too many arguments"
    }
    if { [llength $non_switches] == 2 } { set port [lindex $non_switches 1] }
    set addr [lindex $non_switches 0]


    # Detect a CIDR mask and pull it off the addr string
    if { [set loc [string first "/" $addr end-4]] != -1 } {
        set cidr_bits [string range $addr [expr {$loc + 1}] end]
        set addr [string range $addr 0 [expr {$loc - 1}]]
    }

    # Pull the route-domain off the addr string, but only use it as the
    # route domain if it wasn't overridden by -route_domain flag.
    if { [string first "%" $addr] != -1 } {
        if { $route_domain == 0 } {
            # route-domain is still default, so use value from addr string
            set route_domain [lindex [split $addr "%"] 1]
        }
        set addr [lindex [split $addr "%"] 0]
    }

    if { $do_mask } {

        # Define the delta between ipv4 and ipv6.
        # length: ipv4 mask is 32 bits, ipv6 is 128 bits.
        # group: ipv4 is grouped in octets, ipv6 as 16 bit words.
        # format: ipv4 is decimal notation, ipv6 is hex.
        # format1 also has the delimiter, format2 does not.
        array set v {
            0,length  32
            0,group   8
            0,format1 d.
            0,format2 d
            1,length  128
            1,group   16
            1,format1 .4x:
            1,format2 .4x
        }
        set is_ipv6 [string match "*:*:*" $addr]

        # Soften result of an illegal -length parameter.
        if { ![info exists cidr_bits] || $cidr_bits > $v($is_ipv6,length) } {
            set cidr_bits $v($is_ipv6,length)
        } elseif { $cidr_bits < 0 } {
            set cidr_bits 0
        }

        # Loop on the full length of the mask: 32 bits for ipv4, 128 for ipv6
        for { set octet 0; set i 0 } { $i < $v($is_ipv6,length) } { incr i } {

           # Take a break at intervals to save the grouping and add delimiter.
           # Interval is 8 bits for ipv4 and 16 bits for ipv6.
           if { $i && ![expr {$i % $v($is_ipv6,group)}] } {

               # Add the grouping and delimiter to the mask, then reset.
               append mask [format %$v($is_ipv6,format1) $octet]
               set octet 0
           }
           # Shift the prior bits left by multiplying by 2.
           # Then add the current bit, which is 1 if part of the mask, 0 if not.
           # Current bit is part of the mask if $i < number of bits in the mask.
           set octet [expr { 2 * $octet + ($i < $cidr_bits) }]
        }
        # Add the final grouping, then return the finished mask.
        set ret_val [format $mask%$v($is_ipv6,format2) $octet]

    } else {

        # calculate a destination
        # the route domain might be a name and we need a number.
        if { ![string is integer $route_domain] } {
            set route_domains [tmsh::get_config "/ net route-domain $route_domain"]
            if { [llength $route_domains] != 1 } {
                error "no such route domain: $route_domain"
            }
            # since we have already determined that the list is 1 long,
            # this explicit reference to element 0 is safe
            set route_domain [tmsh::get_field_value [lindex $route_domains 0] "id"]
        }

        set route_domain [expr { $route_domain == 0 ? "" : "%$route_domain" }]

        # 0 and * represent wildcard port assignments in the GUI,
        # but TMSH requires the string 'any' to specify a wildcard.
        if { $port == 0 || $port == "*" } {
            set port any
        }

        # Build the final destination. Use ":" for node names even if ipv6.
        set is_ipv6_literal [string match "*:*:*" $addr]
        set addr_delimiter  [expr { $is_ipv6_literal ? "." : ":" }]
        set ret_val ${addr}${route_domain}${addr_delimiter}${port}
    }
    return $ret_val
}

proc iapp_pool_members { args } {

    # Set defaults.
    array set fields {
        address          addr
        port             port
        port-secure      port_secure
        connection-limit connection_limit
        priority-group   priority
        ratio            ratio
    }
    set route_domain ""
    set port_override -1
    set aaa_domain 0
    set aaa_priority -1
    set app_service ""
    # Set up flag-related work.
    array set flags {
        -fields       { [array set fields  [iapp_pull $ptr args]] }
        -route_domain { [set route_domain  [iapp_pull $ptr args]] }
        -port         { [set port_override [iapp_pull $ptr args]] }
        -aaa_domain   { [set aaa_domain    1] }
        -aaa_pool     { [set aaa_priority  0] }
        -noapp        { [set app_service " app-service none"] }
    }
    iapp_process_flags flags args

    # Identify the non-address/non-port fields. These go inside braces in tmsh.
    set nonport_fields [lsearch -all -not -inline -regexp \
        [array names fields] {address|port|port-secure}]

    set members ""
    foreach row [join $args] {

        # Skip invalid table rows.
        if { [llength [join $row]] %2 == 1 } {
            continue
        }

        # Import APL table into an array for processing.
        array unset columns
        array set columns [join $row]
        set addr $columns($fields(address))

        # Identify the port number, either from table columns or by -port flag.
        if { $port_override != -1 } {
            set port $port_override
        } elseif { [info exists columns($fields(port))] } {
            set port $columns($fields(port))
        } elseif { [info exists columns($fields(port-secure))] } {
            set port $columns($fields(port-secure))
        } else {
            set port 80
        }

        # If specified, strip entered route domain and append the flag value.
        if { $route_domain != "" } {
            set addr [lindex [split $addr "%"] 0]
            set addr "$addr%$route_domain"
        }

        # If -aaa_domain, use domain controller format, otherwise use pool format
        if { $aaa_domain } {
            append members " $columns($fields(host)) \{ ip $addr $app_service \}"
        } else {
            append members " [iapp_destination $addr $port] \{"

            # Transfer non-port fields from the table to the tmsh string.
            foreach name $nonport_fields {
                if { [info exists columns($fields($name))] } {
                    append members " $name $columns($fields($name))"
                }
            }

            # If -aaa_pool, add priority field with incrementing value.
            # This is required by APM.
            if { $aaa_priority >= 0 } {
                append members " priority-group [incr aaa_priority]$app_service"
            }
            append members " \}"
        }
    }

    return "[expr { $aaa_domain ? "" : "members " }][expr { $members eq "" \
        ? "none" : "replace-all-with \{ $members \}" }]"
}

proc iapp_debug { args } {

    # Passwords should be obscured in all logs. Fields shown here are handled
    # in this proc, but the global variable may be overwritten if alternate
    # fields should be obscured.
    if { ![info exists ::SENSITIVES] } {
        set ::SENSITIVES {
            account-password
            admin-encrypted-password
            PASSWORD
            password
            passwd
            proxy-ca-passphrase
            secret
        }
    }

    # look for any of the sensitive words, and replace the word that follows it
    set regex "(\\m([join $::SENSITIVES |])\\M)\\s+\[^\\s\]*"
    regsub -all $regex [join $args] {\1 -OBSCURED-} args
    regsub -all "(<Password.*>).*(</Password>)" $args {\1-OBSCURED-\2} args

    set lev [tmsh::get_field_value [lindex [tmsh::get_config sys scriptd \
        log-level] 0] log-level]
    if { $lev eq {debug} } {
        puts $args
    }
}

# The apm_config proc provides a tmsh pre-processor for APM
# configuration, which in most cases will drastically reduce
# implementation code. To configure APM with this proc, pass
# it an array of object names and associated meta-tag substitutions.
# Each object must be categorized as a profile, a resource, or
# a policy-item. APM agents and customization-groups are derived
# from these 3 categories as needed.
#
# apm_config's return value is a list of the APM profiles defined
# in the argument and instantiated by the proc. This allows the
# procedure call to be embedded directly into a virtual server
# definition.
#
# These universal meta-tags may be placed anywhere in the array:
# <ITEM> The object name, eg. apm_access
# <PREFIX> The app name, including folder, eg. /Common/my_app.app/my_app
#
# Profile objects require the following meta-tags:
# <PROFILE_TYPE> The tmsh object type, eg. "apm profile access"
# <PROFILE_DEF>  The body of the object, eg.:
#     "access-policy <PREFIX>
#      defaults-from /Common/access
#      eps-group <PREFIX>_eps
#      errormap-group <PREFIX>_errormap
#      general-ui-group <PREFIX>_general_ui"
#
# apm_config will automatically create default customization-groups
# for the "-group" lines specified in access profile definitions.
# In the above example, there is no need to additionally specify a
# customization-group for errormap and general-ui.
#
# <PROFILE_TYPE> is a catch-all for other APM types, eg:
#      apm_sso {
#          <PROFILE_TYPE> {apm sso kerberos}
#          <PROFILE_DEF>  "account-name <USER>
#                          account-password <PASS>
#                          realm <REALM>" }
#
# In the example above, <PROFILE_TYPE> and <PROFILE_DEF> are
# apm_config meta-tags, while <USER>, <PASS>, and <REALM> must
# be substituted before calling apm_config, eg. if these tags are
# defined in $pre_proc_map, they may be substituted with:
# array set apm_map [string map [subst $pre_proc_map] [array get apm_map]]
#
# Resource objects require the following meta-tags:
# <RESOURCE_TYPE> The apm resource object type, eg. "webtop"
# <RESOURCE_DEF>  The body of the object, eg.:
#     "customization-group <ITEM>
#      minimize-to-tray false
#      webtop-type full"
#
# In the above example, a customization-group is specified. Any
# customization-group is assumed to be blank unless further defined by the
# <GROUP_DEF> meta-tag, eg. <GROUP_DEF> {type webtop}
#
# Policy-item objects are defined by the following meta-tags:
# <AGENT_TYPE>   default "resource-assign"
# <AGENT_DEF>    default "customization-group <ITEM>"
# <ITEM_AGENT>   default "agents { <ITEM>_ag { type <AGENT_TYPE> }}"
# <ITEM_CAPTION> default "<ITEM>"
# <ITEM_COLOR>   default "1"
# <ITEM_TYPE>    default "action"
# <ITEM_RULES>   defaults to a set of expressions/next-items where specified
# <RULE_CAPTION_0> default "fallback"
# <RULE_CAPTION_1> default "Successful"
# <RULE_CAPTION_2> default "successful"
#
# apm_config generates the APM agent and customization-group definitions
# as required for each policy-item, but specific objects may be defined
# by using the <AGENT_DEF> and <GROUP_DEF> meta-tags.
# To suppress the formation of an APM agent, specify <ITEM_AGENT> {}.

proc iapp_apm_config { args } {

    set app_service ""
    array set flags  {
        -noapp       { [set app_service "app-service none\n   "] }
    }
    iapp_process_flags flags args

    upvar [lindex $args 0] map_array

    # Pull $prefix from the array
    set prefix $map_array(prefix)
    unset map_array(prefix)

    # Stencils for creating apm objects
    set access_form \
       "<TMSH_CREATE> apm policy access-policy <ITEM> {\n   \
          $app_service    caption general\n   \
          start-item <ACCESS_START_ITEM>\n   \
          default-ending <ACCESS_ENDING>\n   \
          items replace-all-with {\n<ACCESS_ITEMS>    }\n}"

    set profile_form "<TMSH_CREATE> <PROFILE_TYPE> <ITEM> {\n   \
        $app_service    <PROFILE_DEF>\n}"

    set resource_form "<TMSH_CREATE> apm resource <RESOURCE_TYPE> <ITEM> {\n   \
        $app_service    <RESOURCE_DEF>\n}"

    set agent_form "<TMSH_CREATE> apm policy agent <AGENT_TYPE> <ITEM>_ag {\n   \
        $app_service    <AGENT_DEF>\n}"

    set group_form "<TMSH_CREATE> apm policy customization-group <ITEM> {\
        $app_service    <GROUP_DEF>}"

    set agent_group_form "<TMSH_CREATE> apm policy customization-group <ITEM>_ag {\
        $app_service    <GROUP_DEF>}"

    set policy_item_form "<TMSH_CREATE> apm policy policy-item <ITEM> {
    $app_service    <ITEM_AGENT>caption <ITEM_CAPTION>
    color <ITEM_COLOR>
    <ITEM_TYPE>
    <ITEM_RULES>\n}"

    # 1st round apm string map
    set default_map_1 {
        <ACCESS_ITEM> {}
        <AGENT_DEF> "customization-group <ITEM>_ag"
        <ITEM_AGENT> "agents replace-all-with {
        <ITEM>_ag { type <AGENT_TYPE> }}\n    "
        <ITEM_CAPTION> <ITEM>
        <ITEM_COLOR> {1}
        <ITEM_TYPE> "item-type action"
        <ITEM_RULES> "rules
        {[expr {[string first <RULE_NEXT_2> $map_array($item)] != -1 ? "{
            caption <RULE_CAPTION_2>
            expression <RULE_EXPR_2>
            next-item ${prefix}_<RULE_NEXT_2>
        }":""}][expr {[string first <RULE_NEXT_1> $map_array($item)] != -1 ? "{
            caption <RULE_CAPTION_1>
            expression <RULE_EXPR_1>
            next-item ${prefix}_<RULE_NEXT_1>
        }":""}]{
            caption <RULE_CAPTION_0>
            next-item ${prefix}_<RULE_NEXT_0>
        }}"
    }

    # 2nd round apm string map
    set default_map_2 {
        <ITEM> [expr { $item eq {default} ? "$prefix" : "${prefix}_$item" }]
        <PREFIX> $prefix
        <LOCAL_PATH> [string map {/ :} $prefix]
        <GROUP_DEF> ""
        <AGENT_TYPE> "resource-assign"
        <RULE_CAPTION_2> "successful"
        <RULE_CAPTION_1> "Successful"
        <RULE_CAPTION_0> "fallback"
    }

    # Build APM access profile and access-policy from the access_form.
    # Tags <ACCESS_ITEM> and <ACCESS_ENDING> are picked up from
    # $map_array items. <ITEM> and <GROUP_DEF> are picked up from
    # $default_map_2.
    foreach item [lsort [array names map_array]] {

        # Pick up the <ACCESS_ENDING> tag. There should be just 1.
        set access_form [string map $map_array($item) $access_form]

        # Filter out items that do not belong in the access-policy.
        # Anything with an ITEM_xxx tag belongs
        if { [string first <ITEM_ $map_array($item)] == -1 } {
            continue
        }

        # Add to the items list for the access-policy, e.g. priority
        append access_items "        ${prefix}_$item {<ACCESS_ITEM>}\n"
        set access_items [string map $map_array($item) $access_items]
        set access_items [string map [subst $default_map_1] $access_items]
    }

    # Build APM resources, policy-items, agents, and customization-groups from
    # the policy_item_form and resource_form.
    foreach item [lsort [array names map_array]] {

        # Each item starts as a profile, a resource, or a policy-item.
        # Profiles are free-form, so other apm objects can use the profile form.
        # In most cases, a policy-item spawns an agent.
        # Any definition specifying a customization-group will spawn that group.
        if { [string first "<PROFILE_DEF>" $map_array($item)] != -1 } {

            # Collect profile names for attachment to the virtual server
            if { [string first "apm profile " $map_array($item)] != -1 } {
                lappend profiles [expr { $item eq {default}
                                 ? "$prefix" : "${prefix}_$item" }]
                # When an access profile is found, built a policy of the same name
                if { [string first "apm profile access" $map_array($item)] != -1 } {
                    set def [string map "<ACCESS_ITEMS> {$access_items}" $access_form]
                    append cmds "[string map [subst $default_map_2] $def]\n"
                }
            }
            set def $profile_form
        } elseif { [string first "<RESOURCE_DEF>" $map_array($item)] != -1 } {
            set def $resource_form
        } else {
            set def $policy_item_form
            if { [string first "<ITEM_AGENT> {}" $map_array($item)] == -1 } {
                append def $agent_form
            }
        }

        # Apply 1st pass of string maps
        set def [string map $map_array($item) $def]
        set def [string map [subst $default_map_1] $def]

        # If a customization-group is specified, add its definition
        if { [string first "customization-group" $def] != -1 } {
            if { [string first "apm policy agent" $def] != -1 } {
                append def $agent_group_form
            } elseif { [string first "apm profile access" $def] == -1 } {
                append def $group_form
            }
        }

        # Apply 2nd pass of string maps
        set def [string map $map_array($item) $def]
        append cmds [string map [subst $default_map_2] $def]
    }

    # Divide and execute tmsh commands
    set tag "<TMSH_CREATE>"
    set tag_length [string length $tag]
    set last [expr { [string first $tag $cmds] + $tag_length }]
    while { [set pos [string first $tag $cmds $last]] != -1 } {
        incr pos -1
        iapp_conf create [string range $cmds $last $pos]
        set last [expr { $pos + $tag_length + 1 }]
    }
    iapp_conf create [string range $cmds $last end]
    return $profiles
}

proc iapp_upgrade_template { upgrade_var upgrade_trans } {
    upvar $upgrade_var   upgrade_var_arr
    upvar $upgrade_trans upgrade_trans_arr

    # create the new variables from the old
    foreach { var } [array names upgrade_var_arr] {

        # substitute old variable name for abbreviation "##"
        regsub -all {##} $upgrade_var_arr($var) \$$var map_cmd

        # run the mapping command from inside the array
        if { [catch { subst $map_cmd } err] } {
            if { [string first "no such variable" $err] == -1 } {
                puts "ERROR $err"
            }
        }
    }

    # move variables over and apply translations
    set var_mods ""
    set var_adds ""
    foreach var [array names vx] {

        # if the APL variable name is in the translation array,
        # then use the custom translation built for that variable.
        if { [info exists upgrade_trans_arr($var)] } {
            array set sub_arr [subst $upgrade_trans_arr($var)]
            if { [info exists sub_arr($vx($var))] } {
                set vx($var) $sub_arr($vx($var))
            }
            array unset sub_arr
        # else, if the APL variable value is in the translation array,
        # then use the generic translation of that value.
        } elseif { [info exists upgrade_trans_arr($vx($var))] } {
            set vx($var) [subst $upgrade_trans_arr($vx($var))]
        }

        # add to tmsh command string
        if { [info exists ::$var] } {
            append var_mods "\n $var \{ value \"$vx($var)\" \} "
        } else {
            append var_adds "\n $var \{ value \"$vx($var)\" \} "
        }
    }

    # move tables over
    set tbl_mods ""
    set tbl_adds ""
    foreach tbl [array names tx] {

        # convert table from APL format to TMSH format
        if { ![llength $tx($tbl)] } {
            set tbl_def "column-names none"
        } else {
            set rows_def ""
            foreach apl_row $tx($tbl) {
                array set row_arr [join $apl_row]
                append rows_def "\n  \{ row \{ "
                foreach apl_col [array names row_arr] {
                    append rows_def "$row_arr($apl_col) "
                }
                append rows_def "\}\}"
            }
            set tbl_def \
            "\n  column-names \{ [array names row_arr] \} rows \{ $rows_def \}"
            array unset row_arr
        }

        # add to tmsh command string
        if { [info exists ::$tbl] } {
            append tbl_mods "\n $tbl \{ $tbl_def \} "
        } else {
            append tbl_adds "\n $tbl \{ $tbl_def \} "
        }
    }

    # construct the "tmsh modify" command
    set cmd "sys application service $tmsh::app_name "
    if { [llength $var_mods] } {
        append cmd "\nvariables modify { $var_mods }"
    }
    if { [llength $var_adds] } {
        append cmd "\nvariables add { $var_adds }"
    }
    if { [llength $tbl_mods] } {
        append cmd "\ntables modify { $tbl_mods }"
    }
    if { [llength $tbl_adds] } {
        append cmd "\ntables add { $tbl_adds }"
    }

    # Execute with debug output. This conversion takes place within the
    # existing ASO, so tmsh modify is used instead of tmsh create.
    iapp_debug "TEMPLATE UPGRADE"
    iapp_conf modify $cmd
    return
}

proc iapp_downgrade_template { pivot_var upgrade_var downgrade_table } {
    upvar $downgrade_table downgrade_tbl_arr

    # The ASO variable "offload_history" is used to recover the legacy
    # choice a user made about SSL offload. It should be present in all cases.
    # This conditional only handles the case where a user has deliberately
    # deleted it by manipulating the ASO directly from tmsh.
    if { ![info exists ::offload_history] } {
        set ::offload_history "No"
    }

    # BIG-IP erases table contents when the APL optional hides the table.
    # Since the prior data is not available, this downgrade must back-convert
    # existing table data. Unlike tables, variables remain intact from the
    # legacy ASO.
    set tbl_def ""
    foreach tbl [array names downgrade_tbl_arr] {
        # Check for existence of each table in the current context.
        # If not, skip to next.
        if { ![info exists [set tbl]] } {
            continue
        }
        # Check for existence of each table in the legacy context.
        # If not, add an empty table so "tmsh tables modify" does not fail.
        if { ![info exists ::$downgrade_tbl_arr($tbl)] } {
            iapp_conf modify sys app ser $tmsh::app_name tables add \{ $downgrade_tbl_arr($tbl) \}
        }
        append tbl_def "$downgrade_tbl_arr($tbl) \{ "
        if { [llength [subst $$tbl]] } {
            set rows_def ""
            foreach apl_row [subst $$tbl] {
                array set row_arr [join $apl_row]
                append rows_def "\n  \{ row \{ "
                foreach apl_col [array names row_arr] {
                    append rows_def "$row_arr($apl_col) "
                }
                append rows_def "\}\}"
            }
            append tbl_def \
            "column-names \{ [array names row_arr] \} rows \{ $rows_def \}"
            array unset row_arr
        } else {
            append tbl_def "rows none"
        }
        append tbl_def " \} "
    }
    regsub -all "\n" $tbl_def {} tbl_def
    set cmd "sys app ser $tmsh::app_name \
        variables modify \{ \
            $pivot_var \{ value $::offload_history \} \
            $upgrade_var \{ value No \} \
        \} \
        tables modify \{ $tbl_def \}"
    iapp_debug "TEMPLATE DOWNGRADE"
    iapp_conf modify $cmd
    return
}

proc iapp_get_ca_certs { args } {
    # Procedure formats and returns ca-bundle 509 certificates from ca-bundle.bak
    # (copy of tmos supplied ca-bundle.crt)
    # Returns backup files when using -files flag
    # Returns specified restore file certificates when using -restore -return flags
    # Returns specified restore file table certificates when using -restore -tablename
    # Returns selected certificates
    #
    # Set defaults. Flag actions may overwrite defaults later.
    set rest_files         0
    set do_restore         0
    set restore_return     0
    set restore_table_name 0
    set do_certs 0
    set user_get [iapp_get_user]
    set username [string range $user_get [expr {[string last user $user_get] +5 }] end-3 ]
    # Set up flag-based actions.
    array set flags  {
        -files     { [set rest_files 1] }
        -return    { [set do_restore 1] [set restore_return 1] }
        -tablename { [set do_restore 1] [set restore_table_name 1] }
        -certs     { [set do_certs 1] }
    }
    iapp_process_flags flags args
    set fn_ca_bundle "[lindex $args 0]"
    set cert_choices "[lindex $args 1]"
    set duplicate " "
    if { $rest_files eq 0 || $do_restore } {
        set fh_ca_bundle [open $fn_ca_bundle r]
        set ca_bundle_data [read $fh_ca_bundle]
        close $fh_ca_bundle
        set ca_bundle_split [split [string map "{-----END CERTIFICATE-----} \001" $ca_bundle_data] "\001"]
        set final ""
        # Grab Subject Name and Serial number from each certificate
        foreach subject $ca_bundle_split {
            if {$subject eq {}} {
                continue
            }
            set a [string first Subject: $subject]
            set b [string first \n $subject $a]
            set ab [string range $subject $a $b]
            set c [expr {[string first O= $ab] +2}]
            if { $c < 2 }{
                set c [expr {[string first CN= $ab] +2}]
            }
            set d [expr {[string first , $ab $c] -1}]
            # Deal with case were comma is not present after subject name
            if { $d < 0 }{
                set dc [string range $ab $c end-1]
            # Deal with case were text is not able to be located using common name, just grab the first 30 characters
            } elseif { $d > 2000 }{
                set dc [string range $ab $c 47]
            } else {
                set dc [string range $ab $c $d]
            }
            set f [expr {[string first Number: $subject] +7}]
            set g [expr {[string first Signature $subject $f] -1}]
            set fg [string range $subject $f $g]
            # Remove spaces and new line characters from serial number
            set fg_nospace [string map {" " "" "\n" "" ":" ""} $fg]
            set first_5 [string map {"(" ""} [string range $fg_nospace 0 4]]
            # -cert flag returns list of selected root certificates
            if { $do_certs }{
                foreach selection $cert_choices {
                    if { $first_5 eq $selection }{
                        # setup to remove duplicate root certificates - tmos supplied ca-bundle can have duplicates
                        set i 0
                        set duplicate_split [split [string map "{ } \001" $duplicate] "\001"]
                        foreach dup $duplicate_split {
                            if { $dup eq $first_5 }{
                                incr i
                            }
                        }
                        # add certificate if not a duplicate
                        if { $i < 1 }{
                            append final "${subject}-----END CERTIFICATE-----\n"
                            puts [tmsh::log notice "User:'${username}' Modified CA-Bundle, adding the following Root CA:(SN) ${fg_nospace} Name:${dc}"]
                            append duplicate "$first_5 "
                        }
                    }
                }
            } elseif { $dc !="" || $fg_nospace !="" || $restore_table_name eq 1 }{
                if { $restore_return eq 0 && $restore_table_name eq 0 }{
                    append final "${dc},SN:${fg_nospace}\t${first_5}\n"
                } elseif { $restore_table_name eq 1 }{
                    set table_cert [string first ### $subject]
                    if { $table_cert > -1 && $table_cert < 500 } {
                        set ending "$subject-----END CERTIFICATE-----"
                        set table_certificate [string range $ending [string first -----BEGIN $ending] [ expr { [string first -----END $ending] +24 }]]
                        append final  "{ row { \"[string map {"\n" " "} $table_certificate]\" \"[string range $subject 4 [expr { [string first \n $subject 1] -1 }]]\" } }"
                    }

                } else {
                    set table_cert [string first ### $subject]
                    if { $table_cert < 0 || $table_cert > 500 } {
                        append final "${first_5} "
                    }
                }
            }
        }
        if { $do_restore && $restore_table_name eq 0 }{
            set final [string map {"(" ""} $final]
        }
        return $final
    }
    if { $rest_files }{
        # Pull TMOS ca-bundle file into list
        catch { set fn_bak_ca_bundle [exec ls -t /config/ssl/ssl.crt/] } err
        if { $::errorCode != "" } {
            puts "Error during file lookup in ssl certificate directory: ${err}"
            error "Error during file lookup in ssl certificate directory: ${err}"
        }
        foreach bak [join "$fn_bak_ca_bundle"] {
            set full_path "/config/ssl/ssl.crt/$bak"
            if { [iapp_is full_path $fn_ca_bundle] }{
                set fn_bak_exists 1
                break
            } else {
                set fn_bak_exists 0
            }
        }
        if { $fn_bak_exists }{
            puts "Backup of factory TMOS ca-bundle /config/ssl/ssl.crt/ca-bundle.crt, at:${fn_ca_bundle}, already exists. No need to backup"
        } elseif { $fn_bak_exists eq 0 }{
            puts "Backing up factory TMOS ca-bundle /config/ssl/ssl.crt/ca-bundle.crt, to ${fn_ca_bundle}."
            catch { exec cp /config/ssl/ssl.crt/ca-bundle.crt ${fn_ca_bundle} } err
            if { $::errorCode != "" } {
                puts "Error creating backup file:${fn_ca_bundle}: ${err}"
                error "Error creating backup file:${fn_ca_bundle}: ${err}"
            }
        }
        set restore_list [lsearch -all -inline $fn_bak_ca_bundle *_bak*]
        set restore_final ""
        foreach res $restore_list {
            append restore_final "${res}\t${res}\n"
        }
        if { $restore_final == "" }{
            return "No restore files found"
        } else {
            return $restore_final
        }
    }
}
}



sys application template f5.http.v1.2.0rc4 {
    actions {
        definition {
            html-help {
<p><strong>web iApp Template</strong></p>

<p>This template creates a complete configuration optimized for managing web traffic. <br>Before you start: </p>
<ul>
    <li>All of the help for this iApp template is found inline. Select <b>Yes, show inline help</b> from the inline help question.</li>
    <li>For a complete walkthrough of this web iApp, as well as detailed information and help, see http://www.f5.com/pdf/deployment-guides/iapp-http-dg.pdf</li>
    <li>Check System :: Resource Provisioning to ensure that LTM (Local Traffic Manager) is provisioned.</li>
    <li>Set up VLANs and Self IP addresses on the networks you use for client-side and server-side traffic.</li>
    <li>If configuring SSL Offload on the BIG-IP system, before running the iApp, import the proper SSL certificate(s) that corresponds to the DNS names used by the clients.</li>
    <li>If you plan to use the iApp to deploy any of the optional modules, the modules must be fully licensed and provisioned before running the iApp.</li>
</ul>
            }
            implementation {
tmsh::include f5.iapp.1.5.1.cli
iapp_template start

set DEFAULT_ANSWER    /#default#
set DO_NOT_USE_ANSWER /#do_not_use#
set CREATE_NEW_ANSWER /#create_new#

proc v11_4_main {} {
    tmsh::include f5.iapp.1.5.1.cli

    # set defaults for non-UI deployments, e.g. REST, in order of appearance
    array set basic_vars {
        ::ssl_encryption_questions__version   {2010}
        ::ifd__deploy_ifd                     {yes}
        ::net__v13_tcp                        {yes}
        ::net__client_mode                    {wan}
        ::net__server_mode                    {lan}
        ::apm__use_apm                        {no}
        ::apm__profile                        {/#create_new#}
        ::apm__auth                           {ntlm}
        ::apm__aaa_profile                    {/#create_new#}
        ::apm__credentials                    {no}
        ::apm__ad_monitor                     {ad_icmp}
        ::apm__policy                         {/#do_not_use#}
        ::ssl__cert                           {/Common/default.crt}
        ::ssl__key                            {/Common/default.key}
        ::asm__use_asm                        {/#do_not_use#}
        ::asm__asm_template                   {POLICY_TEMPLATE_RAPID_DEPLOYMENT}
        ::asm__security_logging               {/#do_not_use#}
        ::asm__language                       {utf-8}
        ::afm__policy                         {/#do_not_use#}
        ::afm__restrict_by_addr               {/#do_not_use#}
        ::afm__restrict_by_reputation         {accept}
        ::afm__staging_policy                 {/#do_not_use#}
        ::afm__security_logging               {/#do_not_use#}
        ::pool__port                          {80}
        ::pool__port_secure                   {443}
        ::pool__pool_to_use                   {/#create_new#}
        ::pool__pool_to_use_wom               {/#do_not_use#}
        ::pool__use_icall                     {No}
        ::pool__encrypted                     {Yes}
        ::pool__fqdn_to_use                   {Yes}
        ::pool__uri_to_use                    {/SitePages/Home.aspx}
        ::pool__sp_port                       {No}
        ::pool__interval_to_use               {60}
        ::pool__profiles                      {}
        ::client__http_compression            {/#create_new#}
        ::monitor__monitor                    {/#create_new#}
        ::monitor__uri                        {/}
        ::monitor__response                   {}
        ::stats__analytics                    {/#do_not_use#}
        ::stats__request_logging              {/#do_not_use#}
    }

    array set advanced_vars {
        ::net__vlan_mode                      {all}
        ::net__snat_type                      {automap}
        ::net__snatpool                       {/#create_new#}
        ::apm__ad_port_ssl                    {636}
        ::apm__ad_port_not_ssl                {389}
        ::ssl__mode_apm                       {client_ssl}
        ::ssl__client_ssl_profile             {/#create_new#}
        ::ssl__use_chain_cert                 {/#do_not_use#}
        ::ssl__server_ssl_profile             {/#create_new#}
        ::afm__dos_security_profile           {/#do_not_use#}
        ::afm__protocol_security_profile      {/#do_not_use#}
        ::pool__mask                          {255.255.255.255}
        ::pool__mirror                        {disabled}
        ::pool__redirect_port                 {80}
        ::pool__http                          {/#create_new#}
        ::pool__persist                       {/#cookie#}
        ::pool__pass_thru_persist             {/#source#}
        ::pool__discourage_persist            {/#do_not_use#}
        ::pool__pass_thru_discourage_persist  {/#do_not_use#}
        ::pool__lb_method                     {round-robin}
        ::pool__min_active_members            {0}
        ::client__standard_caching_with_wa    {/#create_new#}
        ::client__standard_caching_without_wa {/#create_new#}
        ::client__x_wa_info_header            {none}
        ::client__enable_perf_monitor         {no}
        ::client__data_retention_period       {30}
        ::client__policy                      {/Common/Generic Policy - Enhanced}
        ::client__tcp_lan_opt                 {/#create_new#}
        ::client__tcp_wan_opt                 {/#create_new#}
        ::client__isession_profile            {/Common/isession}
        ::server__oneconnect                  {/#create_new#}
        ::server__ntlm                        {/#create_new#}
        ::server__discourage_ntlm             {/#do_not_use#}
        ::server__tcp_lan_opt                 {/#create_new#}
        ::server__tcp_wan_opt                 {/#create_new#}
        ::server__tcp_queue_length            {0}
        ::server__tcp_queue_timeout           {0}
        ::server__slow_ramp_setvalue          {300}
        ::monitor__frequency                  {30}
        ::monitor__post_body                  {}
        ::monitor__user                       {}
        ::monitor__passwd                     {}
    }

    # leftover from 11.3, the "ssl_encryption_questions" APL section remains for backwards compatibility
    set advanced [expr { [iapp_is ::ssl_encryption_questions__advanced yes] \
                 || [iapp_is ::ssl_encryption_questions__legacy_advanced yes]}]

    foreach x [array names advanced_vars] {
        # force advanced config mode for any REST deployment that uses an advanced mode variable
        if { [info exists [set x]] } {
            # undefined ::ssl_encryption_questions__advanced implies a REST deployment
            if { ![info exists ::ssl_encryption_questions__advanced] } {
                set advanced 1
            }
        } else {
            set [set x] $advanced_vars($x)
        }
    }

    foreach x [array names basic_vars] {
        if { ![info exists [set x]] } {
            set [set x] $basic_vars($x)
        }
    }

    set app $tmsh::app_name
    set is_v11_4 [expr {[iapp_tmos_version >= 11.4]}]
    set is_v11_5 [expr {[iapp_tmos_version >= 11.5]}]
    set is_v11_6 [expr {[iapp_tmos_version >= 11.6]}]
    set is_v12_1 [expr {[iapp_tmos_version >= 12.1]}]
    set v13_tcp [expr {[iapp_tmos_version >= 13.0] && [iapp_is ::net__v13_tcp yes]}]
    set lb_lcm_licensed [expr {[string first ltm_lb_least_conn [tmsh::show sys license detail]] != -1}]
    set cookie_licensed [expr {[string first ltm_persist_cookie [tmsh::show sys license detail]] != -1}]
    set is_admin [iapp_get_user -is_admin]
    set use_apm  [expr {[iapp_get_provisioned apm] && [iapp_is ::apm__use_apm yes]}]

    # CLIENT-SIDE VLAN SELECTION
    set select_vlans [iapp_is ::net__vlan_mode enabled disabled]

    # array keys: $advanced,$select_vlans
    array set vlan_arr {
        1,1 { vlans-$::net__vlan_mode vlans replace-all-with \{ $::net__client_vlan \} }
        *   { vlans-disabled vlans none }
    }

    # SNATPOOL PARAMETERS
    set do_snat      [expr { [iapp_is ::net__same_subnet  yes] \
                     || ![iapp_is ::net__route_to_bigip yes] || !$advanced}]
    set do_automap   [expr { [iapp_is ::net__snat_type automap] || !$advanced}]
    set new_snatpool [iapp_is ::net__snatpool $::CREATE_NEW_ANSWER]

    # array keys: $do_snat,$do_automap,$new_snatpool
    array set snatpool_arr {
        1,1,1 { snat automap }
        1,1,0 { snat automap }
        1,0,1 { snatpool [iapp_conf create ltm snatpool ${app}_snatpool \
                members replace-all-with \{ [string map \
                {"addr " "" \{ "" \} ""} $::net__snatpool_members] \} ]}
        1,0,0 { snatpool $::net__snatpool }
        *     { snat none }
    }

    # CLIENT TCP OPTIMIZATION PROFILE
    # In order to show the correct recommendation per the chosen topology,
    # the presentation of client tcp optimization has a split presentation.
    # Only one of tcp_lan_opt or tcp_wan_opt contains the user's selection.
    # This statement identifies whether the user has selected the recommended
    # option from this split presentation.

    # array keys: $::net__client_mode,$::net__server_mode,$v13_tcp
    array set best_tcp_profile {
        lan,lan,0    tcp-lan-optimized
        lan,wan,0    tcp-lan-optimized
        wan,lan,0    tcp-wan-optimized
        wan,wan,0    tcp-wan-optimized
        lan,lan,1    f5-tcp-lan
        lan,wan,1    f5-tcp-lan
        wan,lan,1    f5-tcp-wan
        wan,wan,1    f5-tcp-wan
        lan,tunnel,0 wom-tcp-lan-optimized
        lan,tunnel,1 wom-tcp-lan-optimized
        *            wom-tcp-wan-optimized
    }

    set new_client_tcp [expr { !$advanced || ( \
                       [iapp_is ::net__client_mode lan] ? \
                       [iapp_is ::client__tcp_lan_opt $::CREATE_NEW_ANSWER] : \
                       [iapp_is ::client__tcp_wan_opt $::CREATE_NEW_ANSWER] )}]

    # array keys: $new_client_tcp,$::net__client_mode
    array set client_tcp_arr {
        0,lan    $::client__tcp_lan_opt
        0,wan    $::client__tcp_wan_opt
        0,tunnel $::client__tcp_wan_opt
        *        { [iapp_conf create ltm profile tcp ${app}_[iapp_substa \
                   best_tcp_profile($::net__client_mode,$::net__server_mode,$v13_tcp)] \
                   defaults-from [iapp_substa \
                   best_tcp_profile($::net__client_mode,$::net__server_mode,$v13_tcp)] \
                 ]}
    }


    # SERVER TCP OPTIMIZATION PROFILE
    # See above comments regarding the client tcp optimization array.
    set new_server_tcp [expr { !$advanced || ( \
                       [iapp_is ::net__server_mode lan] ? \
                       [iapp_is ::server__tcp_lan_opt $::CREATE_NEW_ANSWER] : \
                       [iapp_is ::server__tcp_wan_opt $::CREATE_NEW_ANSWER] )}]

    # array keys: $new_server_tcp,$::net__server_mode
    array set server_tcp_arr {
        0,lan    $::server__tcp_lan_opt
        0,wan    $::server__tcp_wan_opt
        0,tunnel $::server__tcp_wan_opt
        *        { [iapp_conf create ltm profile tcp ${app}_[iapp_substa \
                   best_tcp_profile($::net__server_mode,$::net__client_mode,$v13_tcp)] \
                   defaults-from [iapp_substa \
                   best_tcp_profile($::net__server_mode,$::net__client_mode,$v13_tcp)] \
                    ]}
    }

    # CLIENT SSL
    set do_client_ssl [expr { $use_apm || [iapp_is ::ssl__mode client_ssl client_ssl_server_ssl] }]
    set ssl_pass_thru [expr { !$use_apm && [iapp_is ::ssl__mode pass_thru] }]

    set new_client_ssl [expr { !$advanced || [iapp_is \
                       ::ssl__client_ssl_profile $::CREATE_NEW_ANSWER] }]
    set do_chain_cert  [expr { $advanced && \
                       ![iapp_is ::ssl__use_chain_cert $::DO_NOT_USE_ANSWER] }]
    set cssl_cmd \
        "ltm profile client-ssl ${app}_client-ssl defaults-from clientssl"

    # array keys: $do_client_ssl,$new_client_ssl,$do_chain_cert
    array set client_ssl_arr {
        1,1,1 { [iapp_conf create $cssl_cmd key $::ssl__key cert $::ssl__cert \
              chain $::ssl__use_chain_cert] \{ context clientside \} }
        1,1,0 { [iapp_conf create $cssl_cmd key $::ssl__key cert $::ssl__cert \
              chain none] \{ context clientside \} }
        1,0,1 { $::ssl__client_ssl_profile \{ context clientside \} }
        1,0,0 { $::ssl__client_ssl_profile \{ context clientside \} }
        *     {}
    }

    # SERVER SSL PROFILE
    set do_server_ssl [expr { (!$use_apm && [iapp_is ::ssl__mode server_ssl client_ssl_server_ssl]) || ($use_apm && [iapp_is ::ssl__mode_apm client_ssl_server_ssl]) }]

    set default_server [expr { !$advanced || \
                       [iapp_is ::ssl__server_ssl_profile $::DEFAULT_ANSWER] }]

    # array keys: $do_server_ssl,$default_server
    array set server_ssl_arr {
        1,1 { [iapp_conf create ltm profile server-ssl ${app}_server-ssl \
              defaults-from serverssl] \{ context serverside \} }
        1,0 { $::ssl__server_ssl_profile \{ context serverside \} }
        *   {}
    }

    set apm_profiles ""

     # APM
     if { $use_apm } {
         set apm_profiles "$::apm__apm_profile $::apm__apm_sub_profiles /Common/websso /Common/rba"
     }

    # HTTP PROFILE
    set new_http [expr { !$advanced || \
                 [iapp_is ::pool__http $::CREATE_NEW_ANSWER] }]
    set xff_cmd  [expr { (!$advanced || [iapp_is ::pool__xff yes]) \
                 ? "insert-xforwarded-for enabled" \
                 : "insert-xforwarded-for disabled" }]

    # array keys: $ssl_pass_thru,$new_http,$do_client_ssl
    array set http_arr {
        0,0,0 { $::pool__http }
        0,0,1 { $::pool__http }
        0,1,0 { [iapp_conf create ltm profile http ${app}_http \
                 defaults-from http  \
                 redirect-rewrite none $xff_cmd] }
        0,1,1 { [iapp_conf create ltm profile http ${app}_http \
                 defaults-from http   \
                 redirect-rewrite matching $xff_cmd] }
        *     { }
    }

    # COMPRESSION PROFILE
    set do_compress  [expr { !$ssl_pass_thru && \
        ![iapp_is ::client__http_compression $::DO_NOT_USE_ANSWER] }]
    set new_compress [iapp_is ::client__http_compression $::CREATE_NEW_ANSWER]

    # array keys: $do_compress,$new_compress
    array set compress_arr {
        1,1 { [iapp_conf create ltm profile http-compression \
              ${app}_wan-optimized-compression \
              defaults-from wan-optimized-compression \
              content-type-include replace-all-with \{ $::HTTP_CONTENT_TYPES \} \
              ] }
        1,0 { $::client__http_compression }
        *   {}
    }

    # AAM APPLICATION
    # The purpose of the embedded string map is to remove the table column names
    set perf_monitor  [iapp_is ::client__enable_perf_monitor yes]
    set wam_cmd "wam application ${app}_aam hosts replace-all-with \{ \
             [string map {"name " ""} [join [join [expr { [info exists \
             ::pool__hosts] ? "$::pool__hosts" : ""}]]]] \}"

    # array keys: $advanced,$perf_monitor,$ssl_pass_thru
    # "do_configure_wa" need not be keyed here since this is called from
    # caching_arr, which is already keyed on "do_configure_wa".
    array set wam_arr {
        1,1,0 { [iapp_conf create $wam_cmd policy \"$::client__policy\" \
                 info-header $::client__x_wa_info_header \
                 perf-monitor enabled \
                 perf-monitor-data-retention-period \
                 $::client__data_retention_period] }
        1,0,0 { [iapp_conf create $wam_cmd policy \"$::client__policy\" \
                 info-header $::client__x_wa_info_header \
                 perf-monitor disabled \
                 perf-monitor-data-retention-period 0] }
        0,1,0 { [iapp_conf create $wam_cmd \
                 policy \"/Common/Generic Policy - Enhanced\" \
                 info-header none \
                 perf-monitor enabled \
                 perf-monitor-data-retention-period \
                 $::client__data_retention_period] }
        0,0,0 { [iapp_conf create $wam_cmd \
                 policy \"/Common/Generic Policy - Enhanced\" \
                 info-header none \
                 perf-monitor disabled \
                 perf-monitor-data-retention-period 0] }
        *     {}
    }

    # CACHING PROFILE
    set do_configure_wa [expr { !$ssl_pass_thru && [iapp_get_provisioned am] && \
        [iapp_is ::client__use_wa yes] }]
    set do_caching [expr { !$ssl_pass_thru && ($do_configure_wa || \
        ![iapp_is ::client__standard_caching_without_wa $::DO_NOT_USE_ANSWER])}]
    set new_caching [expr { !$advanced || \
        ($do_configure_wa && \
        [iapp_is ::client__standard_caching_with_wa $::CREATE_NEW_ANSWER]) || \
        (!$do_configure_wa && \
        [iapp_is ::client__standard_caching_without_wa $::CREATE_NEW_ANSWER])}]

    # array keys: $do_caching,$new_caching,$do_configure_wa
    array set caching_arr {
        1,1,1 { [iapp_conf create ltm profile web-acceleration \
              ${app}_optimized-acceleration \
              defaults-from optimized-acceleration  \
              applications replace-all-with \{ [iapp_substa \
              wam_arr($advanced,$perf_monitor,$ssl_pass_thru)] \}] }
        1,1,0 { [iapp_conf create ltm profile web-acceleration \
              ${app}_optimized-caching defaults-from optimized-caching \
              applications none cache-size 10  \
              cache-object-max-size 2000000] }
        1,0,1 $::client__standard_caching_with_wa
        1,0,0 $::client__standard_caching_without_wa
        *     {}
    }

    # ONECONNECT PROFILE
    set do_oneconnect  [expr { !$ssl_pass_thru &&  (!$advanced || \
                       ![iapp_is ::server__oneconnect $::DO_NOT_USE_ANSWER])}]
    set new_oneconnect [expr { !$advanced || \
                       [iapp_is ::server__oneconnect $::CREATE_NEW_ANSWER] }]
    set one_cmd "ltm profile one-connect ${app}_oneconnect \
                 defaults-from oneconnect source-mask"

    # array keys: $do_oneconnect,$new_oneconnect,$do_snat
    array set oneconnect_arr {
        1,1,1 { [iapp_conf create $one_cmd 255.255.255.255] }
        1,1,0 { [iapp_conf create $one_cmd 0.0.0.0] }
        1,0,1 $::server__oneconnect
        1,0,0 $::server__oneconnect
        *     {}
    }

    # NTLM PROFILE
    # array keys: $do_oneconnect,$discourage_ntlm,$advanced
    set discourage_ntlm 1
    array set ntlm_arr {
        1,1,1  $::server__ntlm
        *      /#do_not_use#
    }

    # Note: app-service is forced. See BZ448758.
    # array keys: $is_admin,$ntlm_arr($do_oneconnect,$discourage_ntlm,$advanced)
    array set ntlm_cmd {
        0,/#create_new# { [error "Non-admin user cannot create an NTLM profile"] }
        1,/#create_new# { [iapp_conf create ltm profile \
                          ntlm [tmsh::pwd]/${app}_ntlm \
                          defaults-from ntlm \
                          app-service $app] }
        0,/#do_not_use# { }
        1,/#do_not_use# { }
        *               { [iapp_substa ntlm_arr($do_oneconnect,$discourage_ntlm,$advanced)] }
}
    # PERSISTENCE
    set discourage_persist [iapp_is ::ssl_encryption_questions__version 2013]

    # array keys: $discourage_persist,$advanced,$ssl_pass_thru,$cookie_licensed
    array set persist_arr {
        0,0,0,0 /#source#
        0,0,0,1 /#cookie#
        0,0,1,0 /#source#
        0,0,1,1 /#source#
        0,1,0,0 $::pool__persist
        0,1,0,1 $::pool__persist
        0,1,1,0 $::pool__pass_thru_persist
        0,1,1,1 $::pool__pass_thru_persist
        1,1,0,0 $::pool__discourage_persist
        1,1,0,1 $::pool__discourage_persist
        1,1,1,0 $::pool__pass_thru_discourage_persist
        1,1,1,1 $::pool__pass_thru_discourage_persist
        *       /#do_not_use#
    }

    array set persist_cmd {
        /#cookie#     { persist replace-all-with \{ \
                        [iapp_conf create $cookie_cmd] \}\
                        fallback-persistence [iapp_conf create $source_cmd] }
        /#source#     { persist replace-all-with \{ \
                        [iapp_conf create $source_cmd] \}\
                        fallback-persistence none }
        /#do_not_use# { persist none \
                        fallback-persistence none }
        *             { persist replace-all-with \{ [iapp_substa \
        persist_arr($discourage_persist,$advanced,$ssl_pass_thru,$cookie_licensed)] \} \
                        fallback-persistence none }
    }

    set cookie_cmd "ltm persistence cookie ${app}_cookie-persistence "
    set cm_sync_status_details [lindex [tmsh::get_status cm sync-status] 0]
    set cm_sync_status [tmsh::get_field_value $cm_sync_status_details status]
    set mirror_action  [expr { $cm_sync_status eq "Standalone" && [iapp_is \
                       ::pool__mirror enabled] ? "enabled" : "disabled" }]
    set source_cmd     "ltm persistence source-addr \
                       ${app}_source-addr-persistence mirror $mirror_action"

    # ISESSION
    set do_isession   [expr { [iapp_is ::net__server_mode tunnel]
                      && [iapp_get_provisioned am] }]
    set new_isession  [iapp_is ::client__isession_profile $::CREATE_NEW_ANSWER]

    # array keys: $do_isession,$advanced,$new_isession
    array set isession_arr {
        1,1,1 { [iapp_conf create wom profile isession ${app}_isession \
              data-encryption $::client__isession__encryption \
              compression $::client__isession__compression \
              deduplication $::client__isession__deduplication] \
              \{ context serverside \} }
        1,1,0 { $::client__isession_profile \{ context serverside \} }
        1,0,1 { /Common/isession \{ context serverside \} }
        1,0,0 { /Common/isession \{ context serverside \} }
        *     {}
    }

    # IRULES
    set stats_irule {
when HTTP_REQUEST {
  set reqtime [clock clicks]
}
when HTTP_RESPONSE {
  ISTATS::set "sys.application.service <APP> string app-rtt" [expr {[clock clicks] - $reqtime}]
  ISTATS::set "sys.application.service <APP> string tcp-rtt" [TCP::rtt]
}
    }

    set irule_names [expr { !$ssl_pass_thru && [iapp_is ::rtt_stats enabled] \
        ? [iapp_conf create ltm rule ${app}_stats_irule \
          [string map "<APP> [tmsh::pwd]/$app" $stats_irule]] : "" }]

    append irule_names [expr { $advanced && [info exists ::irules__irules] \
        ? " $::irules__irules" : "" }]

    # array key: [llength $irule_names]
    array set irule_arr {
        0 { rules none }
        * { rules \{ $irule_names \} }
    }

    if { $do_client_ssl || $ssl_pass_thru } {
        set redirect_rule [string map [list _PORT $::pool__port_secure] {
when HTTP_REQUEST {
    HTTP::redirect https://[getfield [HTTP::host] : 1]:_PORT[HTTP::uri]
}}]
    }

    # array keys: $::pool__port_secure
    array set redirect_irule {
        443  { _sys_https_redirect }
        *    { [iapp_conf create ltm rule ${app}_https_redirect $redirect_rule] }
    }

    # ASM PROFILE
    set do_asm [expr { [iapp_get_provisioned asm] && \
        !$ssl_pass_thru && ![iapp_is ::asm__use_asm "/#do_not_use#"] }]
    set asm_security_logging [expr { $do_asm && $is_v11_4 && ![iapp_is ::asm__security_logging $::DO_NOT_USE_ANSWER]  ? "\"$::asm__security_logging\"" : "" }]
    set create_asm_policy [expr { [iapp_is ::asm__use_asm "yes"] || [iapp_is ::asm__use_asm $::CREATE_NEW_ANSWER] }]

    # array key: $is_v11_4, $do_asm, $create_asm_policy
    array set asm_policy {
        1,1,1 { policies replace-all-with { \
              [iapp_conf create ltm policy ${app}_policy \
              requires replace-all-with \{ http \} \
              controls replace-all-with \{ asm \} \
              strategy first-match \
              rules replace-all-with \{ \
                  default \{ \
                      ordinal 1 \
                      actions replace-all-with \{ \
                          1 \{ asm enable policy \
                              [iapp_conf create asm policy \
                              ${app}_policy \
                              active \
                              encoding $::asm__language \
                              policy-template \
                              ${::asm__asm_template}_[expr \
                              { $do_client_ssl ? "HTTPS" : "HTTP" }]] \
                          \} \
                      \} \
                  \} \
              \} [expr {$is_v12_1 ? "legacy" : "" }] ] } }
        1,0,1 { policies none }
        0,1,1 { http-class \{ \
              [iapp_conf create asm httpclass-asm ${app}_httpclass \
              language $::asm__language \
              predefined-policy ${::asm__asm_template}_[expr \
              { $do_client_ssl ? "HTTPS" : "HTTP" }] \
              active-policy-name ${app}_asm_policy]
              [iapp_conf create ltm profile httpclass ${app}_httpclass \
              defaults-from httpclass \
              asm enabled \
              web-accelerator [expr {$do_configure_wa ? "enabled":"disabled" }]]\}}
        1,1,0 { policies replace-all-with { $::asm__use_asm } }
        1,0,0 { policies none }
        *   { }
    }

    # FIREWALL (AFM) POLICY
    # beware: syntactically correct AFM commands fail when AFM is not provisioned

    set afm_allowed [expr { $is_v11_4 && $is_admin && [iapp_get_provisioned afm] }]

    set do_firewall [expr { $afm_allowed && ![iapp_is ::afm__policy $::DO_NOT_USE_ANSWER] }]
    set new_firewall [iapp_is ::afm__policy $::DEFAULT_ANSWER]
    set do_ip_intel [expr { $do_firewall && [iapp_is ::afm__restrict_by_reputation "warn" "reject" "select"] }]
    set new_ip_intel [iapp_is ::afm__restrict_by_reputation "warn" "reject"]

    set staging_policy [expr { $do_firewall && \
        ![iapp_is ::afm__staging_policy $::DO_NOT_USE_ANSWER] \
        ? "$::afm__staging_policy" : "none" }]

    set afm_security_logging [expr { $do_firewall && \
        ![iapp_is ::afm__security_logging $::DO_NOT_USE_ANSWER] \
        ? "\"$::afm__security_logging\"" : "" }]
    set security_logging [expr { $is_admin \
        ? "security-log-profiles replace-all-with \{ $asm_security_logging $afm_security_logging \}" : "" }]

    set do_dos_security [expr { $afm_allowed && $advanced && \
        ![iapp_is ::afm__dos_security_profile $::DO_NOT_USE_ANSWER] }]
    set do_protocol_security [expr { $afm_allowed && $advanced && \
        ![iapp_is ::afm__protocol_security_profile $::DO_NOT_USE_ANSWER] }]

    # array key: $afm_allowed,$do_firewall,$new_firewall
    array set firewall_arr {
        1,1,1 { fw-enforced-policy \
                [iapp_conf create security firewall policy ${app}_firewall \
                rules replace-all-with \{ \
                  acceptPackets \{ \
                    action accept \
                    log no \
                    ip-protocol tcp \
                    status enabled \
                    source \{ [iapp_substa afm_restrict($::afm__restrict_by_addr)] \}\} \
                  dropPackets \{ \
                    action drop \
                    log yes \
                    ip-protocol tcp \
                    status enabled \
                    source \{ addresses replace-all-with \{ any/any \}\} \
                  \}\}] \
                fw-staged-policy [subst $staging_policy] }
        1,1,0 { fw-enforced-policy $::afm__policy \
                fw-staged-policy [subst $staging_policy] }
        1,0,1 { fw-enforced-policy none \
                fw-staged-policy none }
        1,0,0 { fw-enforced-policy none \
                fw-staged-policy none }
        *     { }
    }

    # array key: $::afm__restrict_by_addr
    array set afm_restrict {
        /#create_new# {addresses replace-all-with \{ $::afm__allowed_addr \}}
        /#do_not_use# {addresses replace-all-with \{ any/any \}}
        *         {address-lists replace-all-with \{ $::afm__restrict_by_addr \}}
    }

    # ip-intelligence was a profile in 11.4, is a policy in 11.5
    # array keys:
    # $afm_allowed,$do_ip_intel,$new_ip_intel,$is_v11_5,policy/profile
    array set ip_intelligence_arr {
        1,1,1,0,profile { [iapp_conf create security ip-intelligence \
             profile           ${app}_ip_intelligence \
             defaults-from     ip-intelligence \
             botnets           $::afm__restrict_by_reputation \
             denial-of-service $::afm__restrict_by_reputation \
             infected-sources  $::afm__restrict_by_reputation \
             phishing          $::afm__restrict_by_reputation \
             proxy             $::afm__restrict_by_reputation \
             scanners          $::afm__restrict_by_reputation \
             spam-sources      $::afm__restrict_by_reputation \
             web-attacks       $::afm__restrict_by_reputation \
             windows-exploits  $::afm__restrict_by_reputation] }
        1,0,0,1,policy { ip-intelligence-policy none }
        1,0,1,1,policy { ip-intelligence-policy none }
        1,1,0,1,policy { ip-intelligence-policy $::afm__ip_intelligence_policy }
        1,1,1,1,policy { \
             ip-intelligence-policy [iapp_conf create security ip-intelligence \
             policy             ${app}_ip_intelligence \
             default-action     $action($::afm__restrict_by_reputation) \
             blacklist-categories replace-all-with \{ \
                 botnets \{ action use-policy-setting \} \
                 cloud_provider_networks \{ action use-policy-setting \} \
                 denial_of_service \{ action use-policy-setting \} \
                 illegal_websites \{ action use-policy-setting \} \
                 infected_sources \{ action use-policy-setting \} \
                 phishing \{ action use-policy-setting \} \
                 proxy \{ action use-policy-setting \} \
                 scanners \{ action use-policy-setting \} \
                 spam_sources \{ action use-policy-setting \} \
                 web_attacks \{ action use-policy-setting \} \
                 windows_exploits \{ action use-policy-setting \}\}] }
        *    { }
    }

    # array key: $::afm__restrict_by_reputation
    array set action {
        accept { accept default-log-blacklist-hit-only no }
        reject { drop   default-log-blacklist-hit-only yes }
        warn   { accept default-log-blacklist-hit-only yes }
    }

    # ANALYTICS (AVR) PROFILE
    set do_analytics  [expr { $advanced && [iapp_get_provisioned avr] \
        && !$ssl_pass_thru && ![iapp_is ::stats__analytics $::DO_NOT_USE_ANSWER] }]
    set new_analytics [iapp_is ::stats__analytics $::CREATE_NEW_ANSWER]

    # array keys: $do_analytics,$new_analytics
    array set analytics_arr {
        1,1 { [iapp_conf create ltm profile analytics ${app}_analytics \
            defaults-from analytics] }
        1,0 $::stats__analytics
        *   {}
    }

    # REQUEST LOGGING
    set do_logging [expr { $advanced && !$ssl_pass_thru && \
                   ![iapp_is ::stats__request_logging $::DO_NOT_USE_ANSWER] }]

    # array keys: $do_logging
    array set logging_arr {
        1 { $::stats__request_logging }
        0 {}
    }

    # MONITOR SEND STRING
    # only the first FQDN in the hosts table is used for monitoring
    set hostname   [lindex [join [join [expr { [info exists ::pool__hosts] \
                   ? "$::pool__hosts" : "" }]]] 1]
    set http10     [expr {$advanced && [iapp_is ::monitor__http_version http10]}]
    set http_post  [expr {$advanced && [iapp_is ::monitor__http_method POST]}]
    set ntlm_creds [iapp_is ::monitor__credentials ntlm]

    # array keys: $http10,$http_post,$ntlm_creds
    array set send_string_arr {
        1,1,1 { 'POST $::monitor__uri HTTP/1.0\\r\\nContent-Length: [string length $::monitor__post_body]\\r\\nConnection: Keep-Alive\\r\\n\\r\\n$::monitor__post_body' }
        1,1,0 { 'POST $::monitor__uri HTTP/1.0\\r\\nContent-Length: [string length $::monitor__post_body]\\r\\n\\r\\n$::monitor__post_body' }
        1,0,1 { 'GET $::monitor__uri HTTP/1.0\\r\\nConnection: Keep-Alive\\r\\n\\r\\n' }
        1,0,0 { 'GET $::monitor__uri HTTP/1.0\\r\\n\\r\\n' }
        0,1,1 { 'POST $::monitor__uri HTTP/1.1\\r\\nHost: $hostname\\r\\nContent-Length: [string length $::monitor__post_body]\\r\\n$::monitor__post_body' }
        0,1,0 { 'POST $::monitor__uri HTTP/1.1\\r\\nHost: $hostname\\r\\nContent-Length: [string length $::monitor__post_body]\\r\\nConnection: Close\\r\\n\\r\\n$::monitor__post_body' }
        0,0,1 { 'GET $::monitor__uri HTTP/1.1\\r\\nHost: $hostname\\r\\n' }
        *     { 'GET $::monitor__uri HTTP/1.1\\r\\nHost: $hostname\\r\\nConnection: Close\\r\\n\\r\\n'}
    }

    # MONITOR
    set new_pool [expr {( $::net__server_mode ne "tunnel" && \
                 [iapp_is ::pool__pool_to_use $::CREATE_NEW_ANSWER] ) || \
                        ( $::net__server_mode eq "tunnel" && \
                 [iapp_is ::pool__pool_to_use_wom $::CREATE_NEW_ANSWER] )}]
    set new_monitor   [iapp_is ::monitor__monitor $::CREATE_NEW_ANSWER]
    set http_or_https [expr { $do_server_ssl || $ssl_pass_thru ?{https}:{http} }]
    # Check for NTLM, then uppercase the username if it is NTLM
    if { [iapp_is ::monitor__credentials "ntlm"] } {
        set user_index [string first \\ $::monitor__user]
        set monitor_username [string toupper $::monitor__user 0 $user_index]
    } elseif { [iapp_is ::monitor__credentials "basic"] } {
        set monitor_username $::monitor__user
    }
    # array keys: $new_pool,$new_monitor,$advanced
    array set monitor_arr {
        1,1,1 { monitor [iapp_conf create ltm monitor $http_or_https \
              ${app}_${http_or_https}_monitor \
              defaults-from $http_or_https \
              interval $::monitor__frequency \
              timeout [expr { $::monitor__frequency * 3 + 1 } ] \
              [expr { [iapp_is ::monitor__credentials "basic"] || \
                      [iapp_is ::monitor__credentials "ntlm"] ? \
              "username $monitor_username \
               password [iapp_make_safe_password $::monitor__passwd]" : "" }] \
              send [iapp_substa send_string_arr($http10,$http_post,$ntlm_creds)]\
              recv '$::monitor__response'] }
        1,1,0 { monitor [iapp_conf create ltm monitor $http_or_https \
              ${app}_${http_or_https}_monitor \
              defaults-from $http_or_https \
              interval 30 \
              timeout 91 \
              send [iapp_substa send_string_arr($http10,$http_post,$ntlm_creds)]\
              recv '$::monitor__response'] }
        1,0,1 { monitor $::monitor__monitor }
        1,0,0 { monitor $::monitor__monitor }
        *     { monitor none }
    }

    # GENERAL POOL PARAMETERS 1
    set do_slow_ramp [iapp_is ::server__use_slow_ramp yes]
    set do_pga       [iapp_is ::pool__use_pga yes]

    # array keys: $advanced,$do_slow_ramp,$do_pga
    array set pool_ramp_pga_arr {
        1,1,1 { slow-ramp-time $::server__slow_ramp_setvalue \
              min-active-members $::pool__min_active_members }
        1,1,0 { slow-ramp-time $::server__slow_ramp_setvalue \
              min-active-members 0 }
        1,0,1 { slow-ramp-time 10 \
              min-active-members $::pool__min_active_members }
        1,0,0 { slow-ramp-time 10 min-active-members 0 }
        *     { slow-ramp-time 300 min-active-members 0 }
    }

    # GENERAL POOL PARAMETERS 2
    set tcp_queuing [iapp_is ::server__tcp_req_queueing yes]

    # array keys: $advanced,$lb_lcm_licensed,$tcp_queuing
    array set pool_lb_queue_arr {
        1,1,1 { load-balancing-mode $::pool__lb_method \
                queue-on-connection-limit enabled \
                queue-depth-limit $::server__tcp_queue_length \
                queue-time-limit  $::server__tcp_queue_timeout }
        1,0,1 { load-balancing-mode $::pool__lb_method \
                queue-on-connection-limit enabled \
                queue-depth-limit $::server__tcp_queue_length \
                queue-time-limit  $::server__tcp_queue_timeout }
        1,1,0 { load-balancing-mode $::pool__lb_method \
                queue-on-connection-limit disabled }
        1,0,0 { load-balancing-mode $::pool__lb_method \
                queue-on-connection-limit disabled }
        0,0,1 { load-balancing-mode round-robin \
                queue-on-connection-limit disabled }
        0,0,0 { load-balancing-mode round-robin \
                queue-on-connection-limit disabled }
        *     { load-balancing-mode least-connections-member \
                queue-on-connection-limit disabled }
    }

    # POOL
    set no_pool [expr {( $::net__server_mode ne "tunnel" && \
                [iapp_is ::pool__pool_to_use $::DO_NOT_USE_ANSWER] ) || \
                       ( $::net__server_mode eq "tunnel" && \
                [iapp_is ::pool__pool_to_use_wom $::DO_NOT_USE_ANSWER] )}]

    # array keys: $new_pool,$no_pool
    array set pool_arr {
        1,0 { [iapp_conf create ltm pool ${app}_pool \
              [iapp_substa pool_ramp_pga_arr($advanced,$do_slow_ramp,$do_pga)] \
              [iapp_substa pool_lb_queue_arr($advanced,$lb_lcm_licensed,$tcp_queuing)] \
              [iapp_substa monitor_arr($new_pool,$new_monitor,$advanced)] \
              [iapp_pool_members $::pool__members]] \
              translate-address enabled }
        0,0 { [expr { $::net__server_mode ne "tunnel" ? \
              $::pool__pool_to_use : $::pool__pool_to_use_wom }] \
              translate-address enabled }
        *   { none translate-address [expr { $do_isession ? "disabled" : "enabled" }] }
    }

    # VIRTUAL SERVERS
    set secure_client [expr { $do_client_ssl || $ssl_pass_thru }]
    set do_redirect [expr { [iapp_is ::pool__redirect_to_https yes] || \
             !$advanced}]
    set mask [expr { $advanced && $::pool__mask ne "" \
             ? $::pool__mask : [iapp_destination -mask $::pool__addr] }]

    # array keys: $secure_client,$do_redirect
    array set vs_arr {
        1,1 { [iapp_conf create ltm virtual ${app}_vs \
            destination [iapp_destination $::pool__addr $::pool__port_secure] \
            mask $mask \
            $vs_params \
            ip-protocol tcp \
            mirror $mirror_action \
            profiles replace-all-with \{ $vs_profiles \} [expr { $is_v11_6 ? "per-flow-request-access-policy [expr { $use_apm && $::apm__apm_policy != "/#do_not_use#" ? "$::apm__apm_policy" : "none" }]" : "" }]] \
            \
            [iapp_conf create ltm virtual ${app}_redir_vs \
            destination [iapp_destination $::pool__addr $::pool__redirect_port] \
            mask $mask \
            $redir_vs_params \
            ip-protocol tcp \
            mirror $mirror_action \
            profiles replace-all-with \{ $tcp_profiles http \} \
            rules \{ [iapp_substa redirect_irule($::pool__port_secure)] \}]}
        1,0 { [iapp_conf create ltm virtual ${app}_vs \
            destination [iapp_destination $::pool__addr $::pool__port_secure] \
            mask $mask \
            $vs_params \
            ip-protocol tcp \
            mirror $mirror_action \
            profiles replace-all-with \{ $vs_profiles \} [expr { $is_v11_6 ? "per-flow-request-access-policy [expr { $use_apm && $::apm__apm_policy != "/#do_not_use#" ? "$::apm__apm_policy" : "none" }]" : "" }]] }
        *   { [iapp_conf create ltm virtual ${app}_vs \
            destination [iapp_destination $::pool__addr $::pool__port] \
            mask $mask \
            $vs_params \
            ip-protocol tcp \
            mirror $mirror_action \
            profiles replace-all-with \{ $vs_profiles \} [expr { $is_v11_6 ? "per-flow-request-access-policy [expr { $use_apm && $::apm__apm_policy != "/#do_not_use#" ? "$::apm__apm_policy" : "none" }]" : "" }]] }
    }

    # MAIN
    # Array contents (including TCL code) are evaluated during the
    # assignments below. TMSH parameters and profile names are collected
    # for use in subsequent calls including the creation of the virtual
    # server(s). Many parameters are shared between the redirect virtual
    # server and the main virtual server. This builds the redirect
    # parameters first, then re-uses them when constructing the main
    # virtual parameter list.
    set redir_vs_params \
    "[iapp_substa vlan_arr($advanced,$select_vlans)] \
     [iapp_substa snatpool_arr($do_snat,$do_automap,$new_snatpool)] \
     [iapp_substa firewall_arr($afm_allowed,$do_firewall,$new_firewall)] \
     [iapp_substa \
     ip_intelligence_arr($afm_allowed,$do_ip_intel,$new_ip_intel,$is_v11_5,policy)]"

    set vs_params "$redir_vs_params $security_logging \
        [iapp_substa persist_cmd([iapp_substa \
        persist_arr($discourage_persist,$advanced,$ssl_pass_thru,$cookie_licensed)])] \
        pool [set pool_name [iapp_substa pool_arr($new_pool,$no_pool)]] \
        [iapp_substa irule_arr([llength $irule_names])] \
        [iapp_substa asm_policy($is_v11_4,$do_asm,$create_asm_policy)]"

    # TMSH syntax dictates that a profile may only be mentioned once.
    # If the same profile is used in 2 contexts, then specify "context all".
    set client_tcp [iapp_substa \
        client_tcp_arr($new_client_tcp,$::net__client_mode)]
    set server_tcp [iapp_substa \
        server_tcp_arr($new_server_tcp,$::net__server_mode)]

    if { $client_tcp eq $server_tcp } {
        set tcp_profiles "$client_tcp \{ context all \} "
    } else {
        set tcp_profiles "$client_tcp \{ context clientside \} \
                               $server_tcp \{ context serverside \} "
    }

    # Order is important to the "context clientside" and "context serverside"
    # parameters, so those parameters without context must come after those
    # with context. For example, HTTP must come after TCP and SSL.
    set http_name [iapp_substa http_arr($ssl_pass_thru,$new_http,$do_client_ssl)]

    set vs_profiles "[iapp_substa \
            client_ssl_arr($do_client_ssl,$new_client_ssl,$do_chain_cert)] \
        [iapp_substa server_ssl_arr($do_server_ssl,$default_server)] \
        [iapp_substa isession_arr($do_isession,$advanced,$new_isession)] \
        $tcp_profiles $http_name \
        [iapp_substa ip_intelligence_arr($afm_allowed,$do_ip_intel,$new_ip_intel,$is_v11_5,profile)] \
        [expr { $do_dos_security ? "$::afm__dos_security_profile" : "" }] \
        [expr { $do_protocol_security ? "$::afm__protocol_security_profile" : "" }] \
        [iapp_substa compress_arr($do_compress,$new_compress)] \
        [iapp_substa \
            caching_arr($do_caching,$new_caching,$do_configure_wa)] \
        [iapp_substa \
            oneconnect_arr($do_oneconnect,$new_oneconnect,$do_snat)]  \
        [iapp_substa ntlm_cmd($is_admin,[iapp_substa ntlm_arr($do_oneconnect,$discourage_ntlm,$advanced)])] \
        [iapp_substa analytics_arr($do_analytics,$new_analytics)] \
        [expr { $do_asm && $is_v11_4 ? "websecurity " : "" }] \
        [iapp_substa logging_arr($do_logging)] \
        $apm_profiles $::pool__profiles"

    set vs_name [iapp_substa vs_arr($secure_client,$do_redirect)]

    if { [iapp_is ::app_stats enabled] } {
        # START EMBEDDED ICALL SCRIPT
        set icall_script_tmpl {

            set app APP
            set folder FOLDER
            tmsh::cd $folder

            set aso             "sys.application.service ${folder}/$app"
            set virtual_path    "ltm virtual VS"
            set http_path       "ltm profile http HTTP"
            set pool_path       "ltm pool POOL"

            # these lists represent strings taken from "show ... field-fmt"
            set http_stats { get-reqs number-reqs post-reqs resp-5xx-cnt }
            set virtual_stats {
                clientside.bits-in clientside.bits-out clientside.cur-conns
                clientside.max-conns clientside.pkts-in clientside.pkts-out
                clientside.tot-conns status.availability-state status.enabled-state
                status.status-reason
            }
            set pool_stats {
                active-member-cnt serverside.bits-in serverside.bits-out
                serverside.cur-conns serverside.max-conns serverside.pkts-in
                serverside.pkts-out serverside.tot-conns
            }

            if { [catch {
                # loop over each type of object we want to look at, building the name
                # of the path and the stats for it as needed
                foreach type { HTYPE virtual PTYPE } {
                    # making this its own variable made the Tcl validator stop throwing
                    # a warning - though it _should_ be fine to move it inline w/its use
                    set path [set ${type}_path]
                    set objs [tmsh::get_status $path raw]
                    if { [llength $objs] == 0 } {
                        puts "no object found for: $type"
                        continue
                    }
                    set obj [lindex $objs 0]
                    foreach stat [set ${type}_stats] {
                        set value [tmsh::get_field_value $obj $stat]
                        # associate the iStat with the app service
                        istats::set "$aso string $stat" $value
                    }
                }

                # Set an additional iStat for the size of the pool, updated on
                # each iCall iteration in case the size of an external pool changes.
                # Check first that the pool is configured with at least one member.
                set pool_size 0
                if { "POOL" ne "none" && [string first "members" [tmsh::list $pool_path]] != -1 } {
                    set pools [tmsh::get_config $pool_path]
                    if { [llength $pools] == 1 } {
                        set pool [lindex $pools 0]
                        set pool_size [llength [tmsh::get_field_value $pool members]]
                    }
                }
                istats::set "$aso string total-member-cnt" $pool_size
            } err] } {
                istats::set "$aso string app_stats.publish" "Failure in iCall script ${folder}/publish_stats while collecting application statistics: $err"
            } else {
                istats::set "$aso string app_stats.publish" "Published"
            }
        }; # END EMBEDDED ICALL SCRIPT

        # used to fill in variables within iCall script
        set script_map [list    APP         $tmsh::app_name \
                                FOLDER      [tmsh::pwd] \
                                VS          [lindex $vs_name 0] \
                                HTTP        [lindex $http_name 0] \
                                POOL        [lindex $pool_name 0] \
            HTYPE       [expr { $ssl_pass_thru ? {} : {http} }] \
            PTYPE       [expr { $no_pool ? {} : {pool} }]]

        set icall_script_src [string map $script_map $icall_script_tmpl]
        iapp_conf create sys icall script publish_stats \
            definition \{ $icall_script_src \}
        iapp_conf create sys icall handler periodic publish_stats \
            interval 60 script publish_stats
        set aso "sys.application.service ${app}.app/$app"
        catch { exec istats set "$aso string app_stats.publish" "Starting" } err
    }
}

# This array customizes the assignment of old variables to the vx and tx arrays,
# which are used to construct the new variables in tmsh. Since the old variable
# name is almost always used during this assignment, "##" may be used as an
# abbreviation. The assignment of ssl_encryption_questions__legacy_advanced
# is long, but it merely sets the new template context to "basic" or "advanced"
# based on the complexity of the user's application.
array set upgrade_var_arr {
    ::ssl_encryption_questions__offload_ssl { \
         [set vx(offload_history) ##] \
         [set vx(ssl_encryption_questions__offload_ssl) "legacy"] \
         [set vx(ssl_encryption_questions__legacy_advanced) [expr { \
           ( ![iapp_get_provisioned avr] || \
             [iapp_is ::analytics__add_analytics {No}] ) && \
             [iapp_is ::basic__snat              {No}]   && \
             [iapp_is ::basic__need_snatpool     {No}]   && \
             [iapp_is ::basic__using_ntlm        {No}]   && \
             [iapp_is ::server_pools__tcp_request_queuing_enable_question \
                                                  {No}]   && \
           ( [iapp_is ::server_pools__create_new_monitor {Use Monitor...}] || \
           ( [string equal -length 3 $::server_pools__monitor_send   {GET}] && \
             [iapp_is ::server_pools__monitor_http_version  {Version 1.0}] )) \
             ?no:yes}]]}
    ::ssl_encryption_questions__offload_ssl_1    {[set vx(ssl__mode)        ##]}
    ::ssl_encryption_questions__offload_ssl_2    {[set vx(ssl__mode)        ##]}
    ::ssl_encryption_questions__cert             {[set vx(ssl__cert)        ##]}
    ::ssl_encryption_questions__key              {[set vx(ssl__key)         ##]}
    ::analytics__add_analytics                   {[set vx(stats__analytics) \
        [expr { ## eq {No} ? {No} : \
        [expr { $::analytics__create_new_analytics eq {Yes} ? {Yes} : \
        $::analytics__analytics_profile }] }] ]}
    ::basic__addr                       {[set vx(pool__addr)                ##]}
    ::basic__port                       {[set vx(pool__port)                ##]}
    ::basic__secure_port                {[set vx(pool__port_secure)         ##]}
    ::basic__create_redir               {[set vx(pool__redirect_to_https)   ##]}
    ::basic__redir_port                 {[set vx(pool__redirect_port)       ##]}
    ::basic__snat                       {[set vx(net__same_subnet)          ##]}
    ::basic__need_snatpool              {[set vx(net__snat_type)            ##]\
                                         [set vx(net__snatpool)             ##]}
    ::basic__snatpool_members           {[set tx(net__snatpool_members)     ##]}
    ::basic__using_ntlm                 {[set vx(server__ntlm)              ##]}
    ::server_pools__create_new_pool     {[set vx(pool__pool_to_use)         ##]}
    ::server_pools__lb_method_choice    {[set vx(pool__lb_method)           ##]}
    ::server_pools__tcp_request_queuing_enable_question \
                                        {[set vx(server__tcp_req_queueing)  ##]}
    ::server_pools__tcp_request_queue_length \
                                        {[set vx(server__tcp_queue_length)  ##]}
    ::server_pools__tcp_request_queue_timeout \
                                        {[set vx(server__tcp_queue_timeout) ##]}
    ::server_pools__create_new_monitor  {[set vx(monitor__monitor) \
     [expr { ## eq {Use Monitor...} ?$::server_pools__reuse_monitor_name:## }]]}
    ::server_pools__servers             {[set tx(pool__members)             ##]}
    ::server_pools__monitor_interval    {[set vx(monitor__frequency)        ##]}
    ::server_pools__monitor_send  {[set vx(monitor__http_method) [lindex ## 0]]\
                                   [set vx(monitor__uri)     [lrange ## 1 end]]}
    ::server_pools__monitor_http_version    {[set vx(monitor__http_version) ##]}
    ::server_pools__monitor_dns_name { \
                                   [set tx(pool__hosts) [subst {{ name ## }}] ]}
    ::server_pools__monitor_recv        {[set vx(monitor__response)         ##]}
    ::optimizations__lan_or_wan         {[set vx(net__client_mode)          ##]\
                                         [set vx(client__tcp_lan_opt)       ##]\
                                         [set vx(client__tcp_wan_opt)       ##]\
                                         [set vx(client__http_compression)  ##]}
    ::optimizations__use_wa { \
                     [expr { [iapp_get_provisioned am] \
                         && ![iapp_get_provisioned asm] \
                     ? [set vx(client__use_wa) ##] : { }}]\
                     [set vx(client__standard_caching_with_wa)              ##]\
                     [set vx(client__standard_caching_without_wa)           ##]}
    ::optimizations__x_wa_info_header {[set vx(client__x_wa_info_header)    ##]}
    ::optimizations__perf_monitor     {[set vx(client__enable_perf_monitor) ##]}
    ::optimizations__policy           {[set vx(client__policy)              ##]}
    ::optimizations__use_asm          {[expr { [iapp_get_provisioned asm] && \
                                       ![iapp_get_provisioned am] \
                                       ? [set vx(asm__use_asm) ##] : { }}]}
    ::optimizations__use_wa_or_asm    { \
          [set vx(client__use_wa) \
              [expr { [iapp_get_provisioned am] && [iapp_get_provisioned asm]\
             && [iapp_is ::optimizations__use_wa_or_asm "Use WAM"] ?yes:no }]]\
          [set vx(client__standard_caching_with_wa) \
              [expr { [iapp_get_provisioned am] && [iapp_get_provisioned asm]\
             && [iapp_is ::optimizations__use_wa_or_asm "Use WAM"] ?yes:no }]]\
          [set vx(client__standard_caching_without_wa) \
              [expr { [iapp_get_provisioned am] && [iapp_get_provisioned asm]\
             && [iapp_is ::optimizations__use_wa_or_asm "Use WAM"] ?yes:no }]]\
          [set vx(asm__use_asm) \
              [expr { [iapp_get_provisioned am] && [iapp_get_provisioned asm]\
             && [iapp_is ::optimizations__use_wa_or_asm "Use ASM"] ?yes:no }]]}
    ::optimizations__language         {[set vx(asm__language)               ##]}
}

# Two types of translation are supported in this array. If the key is literal,
# then the translation is applied to all ASO variables. If the key is a variable
# name, then the translation is applied only to that variable.

array set upgrade_trans_arr [subst {
    {Create New Pool}     $CREATE_NEW_ANSWER
    {Create New Monitor}  $CREATE_NEW_ANSWER
    {Use Default Profile} $::DEFAULT_ANSWER
    Yes                   yes
    No                    no
    enabled               yes
    disabled              no
    {Version 1.0}         http10
    {Version 1.1}         http11
    LAN                   lan
    WAN                   wan
    offload_history {
        Yes  Yes
        No   No
    }
    net__snat_type {
        Yes  snatpool
        No   automap
    }
    net__need_snatpool {
        Yes  $CREATE_NEW_ANSWER
        No   no
    }
    ssl__mode {
        Yes  client_ssl
        No   no_ssl
    }
    server__ntlm {
        Yes  /Common/ntlm
        No   $DO_NOT_USE_ANSWER
    }
    monitor__response {
        none { }
    }
    stats__analytics {
        Yes  $CREATE_NEW_ANSWER
        No   $DO_NOT_USE_ANSWER
    }
}]

array set downgrade_tbl_arr {
    ::pool__members         server_pools__servers
    ::pool__hosts           optimizations__hosts
    ::net__snatpool_members basic__snatpool_members
}

# ABOUT LEGACY MODE, UPGRADE, AND DOWNGRADE
#
# The variable ::ssl_encryption_questions__offload_ssl is inherited from the
# v11.3 F5.HTTP template and is used to determine whether a template originated
# in a prior release. The purpose is to maintain the user's original selections
# while making the legacy option unavailable for new applications.
#
# Values of ::ssl_encryption_questions__offload_ssl:
#     - does not exist => template in v11.4 mode
#     - "Yes" or "No" => template in v11.3 mode
#     - "legacy" => template created v11.3, now in v11.4 mode
#
# The variable ssl_encryption_questions__advanced allows the user to select
# the complexity of the options presented in the template. If the template
# was originally created pre v11.3, then a different choice variable is used
# which provides the additional option of returning to the legacy mode.
#
# Values of ::ssl_encryption_questions__advanced:
#     - "yes" => v11.4 advanced configuration mode
#     - "no" => v11.4 basic configuration mode
#
# Values of ::ssl_encryption_questions__legacy_advanced:
#     - "yes" => v11.4 advanced configuration mode
#     - "no" => v11.4 basic configuration mode
#     - "legacy" => v11.4 user chooses to return to v11.3 view.
#       This option is not available to virgin v11.4 applications.
#
# When a user upgrades this template from v11.3 to v11.4 mode, the value
# of ::ssl_encryption_questions__offload_ssl is stored in ::offload_history.
# This value is recovered if the user later opts to return to v11.3 mode.

set do_v11_3  [expr { [iapp_is ssl_encryption_questions__offload_ssl Yes] \
                   || [iapp_is ssl_encryption_questions__offload_ssl No] }]
set upgrade   [iapp_is ssl_encryption_questions__upgrade Yes]
set downgrade [iapp_is ssl_encryption_questions__legacy_advanced legacy]

# array keys: $do_v11_3,$upgrade,$downgrade
array set main {
    0,0,0 { [v11_4_main] }
    0,1,0 { [v11_4_main] }
    0,1,1 { [iapp_downgrade_template ssl_encryption_questions__offload_ssl \
             ssl_encryption_questions__upgrade downgrade_tbl_arr] }
    0,0,1 { [iapp_downgrade_template ssl_encryption_questions__offload_ssl \
             ssl_encryption_questions__upgrade downgrade_tbl_arr] }
    1,1,0 { [iapp_upgrade_template upgrade_var_arr upgrade_trans_arr] }
    1,1,1 { [iapp_upgrade_template upgrade_var_arr upgrade_trans_arr] }
    *     { [package require iapp_legacy 1.0.0] \
            [tmsh::include "f5.app_utils"] \
            [iapp_legacy::http::configure_http_deployment "POLICY_TEMPLATE_RAPID_DEPLOYMENT"] }
}

iapp_substa main($do_v11_3,$upgrade,$downgrade)
iapp_template stop

            }
            presentation {

include "/Common/f5.apl_common"

section intro {
    message early_release "This template has not yet been fully tested at F5, and therefore has limited support. When testing is complete, it will move from the RELEASE CANDIDATE directory to parent directory of the iApp template package." 

        # APL choice values may be set even if the optional
        # clause is not true. This trick is useful for setting
        # values that APL otherwise would not have access to.
        # Here, system provisioning values are recalled, and later
        # used to customize messages displayed within the template.
        optional ( "HIDE" == "THIS" ) {
            choice am_provisioned tcl {
                
                return [expr {[tmsh::run_proc f5.iapp.1.5.1.cli:iapp_get_provisioned am] ? "yes" : "no"}]
            }
            choice apm_provisioned tcl {
                
                return [expr {[tmsh::run_proc f5.iapp.1.5.1.cli:iapp_get_provisioned apm] ? "yes" : "no"}]
            }
            choice asm_provisioned tcl {
                
                return [expr {[tmsh::run_proc f5.iapp.1.5.1.cli:iapp_get_provisioned asm] ? "yes" : "no"}]
            }
            choice asm_policy tcl {
                 
                 return [expr {[tmsh::run_proc f5.iapp.1.5.1.cli:iapp_get_items -nocomplain -filter controls =~ asm ltm policy] ne "" ? "yes" : "no"}]
            }
            choice afm_allowed tcl {
                
                return [expr { [tmsh::run_proc f5.iapp.1.5.1.cli:iapp_get_provisioned afm] ? "yes" : "no"}]
            }
            choice analytics_provisioned tcl {
                
                return [expr {[tmsh::run_proc f5.iapp.1.5.1.cli:iapp_get_provisioned avr] ? "yes" : "no"}]
            }
            choice is_admin tcl {
                
                return [expr { [tmsh::run_proc f5.iapp.1.5.1.cli:iapp_get_user -is_admin] ? "yes" : "no"}]
            }
            choice is_v11_4 tcl {
                
                return [expr {[tmsh::run_proc f5.iapp.1.5.1.cli:iapp_tmos_version >= 11.4] ? "yes" : "no"}]
            }
            choice is_v11_6 tcl {
                
                return [expr {[tmsh::run_proc f5.iapp.1.5.1.cli:iapp_tmos_version >= 11.6] ? "yes" : "no"}]
            }
            choice is_v13_0 tcl {
                
                return [expr {[tmsh::run_proc f5.iapp.1.5.1.cli:iapp_tmos_version >= 13.0] ? "yes" : "no"}]
            }
        }

        message hello "Configure security, high availability, and acceleration for web applications. This template supports basic web services. For detailed information and configuration assistance, see http://www.f5.com/pdf/deployment-guides/iapp-http-dg.pdf."
        message check_for_updates "Check for new versions of this template on the AskF5 Knowledge Base website (http://support.f5.com/kb/en-us/solutions/public/13000/400/sol13422.html)."

        optional ( am_provisioned == "no" ) {
            message am_not_provisioned "This system is not currently provisioned to run the BIG-IP Application Acceleration Manager (AAM). Provisioning AAM provides acceleration and optimization for your web applications."
        }
        optional ( analytics_provisioned == "no" ) {
            message analytics_not_provisioned "The system is not currently provisioned to run the BIG-IP Application Visibility Reporting Module (AVR). Activating this module provides rich application statistics and reporting for your deployment."
        }
        optional ( asm_provisioned == "no" ) {
            message asm_not_provisioned "This system is not currently provisioned to run the BIG-IP Application Security Module (ASM). Provisioning ASM can help to secure your web applications."
        }
    }

    section ssl_encryption_questions {

        # If this variable is present, then the user is re-parenting from
        # a v11.3 or earlier template. This condition causes the system
        # to display the old template along with an offer to upgrade.
        optional ( "HIDE" == "THIS" ) {
            choice offload_ssl default "no_legacy" { "Yes"  , "No"  , "legacy"  , "no_legacy" }
        }

        # For v11.3 applications
        optional ( offload_ssl == "Yes" || offload_ssl == "No" ) {
            message deprecated "This template has been deprecated. It is highly recommended that you upgrade this deployment to the current template version. To upgrade, choose Yes below. Note that this process will temporarily take your application offline."

            choice upgrade default "No" display "small" { "Yes" => "Yes"  , "No"  => "No" }

            message gap_1 ""
            message gap_2 ""
            message section_head ""
        }
        optional ( offload_ssl == "Yes" ) {
            choice offload_ssl_1 default "Yes" { "Yes" => "Yes"  , "No"  => "No" }
        }
        optional ( offload_ssl == "No" ) {
            choice offload_ssl_2 default "No" { "Yes" => "Yes"  , "No"  => "No" }
        }
        optional ((ssl_encryption_questions.offload_ssl == "Yes"
                && ssl_encryption_questions.offload_ssl_1 == "Yes" )
                || (ssl_encryption_questions.offload_ssl == "No"
                && ssl_encryption_questions.offload_ssl_2 == "Yes" )) {

            choice cert default "/Common/default.crt" display "xxlarge" tcl {
                
                set ::choices [tmsh::run_proc f5.iapp.1.5.1.cli:iapp_get_items -norecursive -filter NAME !~ ca-bundle.crt|f5-irule.crt sys file ssl-cert]
                return [tmsh::run_proc f5.iapp.1.5.1.cli:iapp_safe_display ::choices]
            }

            choice key default "/Common/default.key" display "xxlarge" tcl {
                
                set ::choices [tmsh::run_proc f5.iapp.1.5.1.cli:iapp_get_items -norecursive sys file ssl-key]
                return [tmsh::run_proc f5.iapp.1.5.1.cli:iapp_safe_display ::choices]
            }
        }

        # For v11.4 applications
        optional ( offload_ssl == "legacy" || offload_ssl == "no_legacy" ) {

            choice help display "xxlarge" default "hide" {

            "Yes, show inline help" => "max"  ,
            "No, do not show inline help" => "hide"
    }
            optional ( help == "max" ) {
                message help_max "Inline help is available to provide contextual descriptions to aid in the completion of this configuration.  Select to show or hide the inline help in this template. Important notes and warnings are always visible, no matter which selection you make here. "
            }
            optional ( offload_ssl == "legacy" ) {
                choice legacy_advanced display "xxlarge" default "no" {

            "Basic - Use F5's recommended settings" => "no"  ,
            "Advanced - Configure advanced options" => "yes"  ,
            "Legacy - Return to the deprecated template" => "legacy"

    }
                optional ( legacy_advanced == "legacy" ) {
                    message legacy_warning "Downgrading to the legacy template will temporarily take your application offline and return all non-table entries to their pre-upgrade values. Any changes made after the upgrade will be lost. To complete the downgrade, click Finished, then Reconfigure, then Finished."
                }
            }
            optional ( offload_ssl == "no_legacy" ) {
                choice advanced display "xxlarge" default "no" {
            "Basic - Use F5's recommended settings" => "no"  ,
            "Advanced - Configure advanced options" => "yes"
    }
                optional ( help == "max" ) {
                    message conf_mode_max "This template supports basic and advanced configurations modes. Basic mode exposes the most commonly used settings, and automatically configures the rest of the options based on F5's recommended settings.  Advanced mode allows you to review and change all settings. If you are unsure, select Basic."
                }

            }
        }
    }

    # For post-v11.4 applications
    optional ( ssl_encryption_questions.offload_ssl == "legacy"
             || ssl_encryption_questions.offload_ssl == "no_legacy" ) {

        section net {
            optional ( intro.is_v13_0 == "yes" ) {
                choice v13_tcp display "xxlarge" default "warn" {
        "Please select one" => "warn"  ,
        "No, use the older profiles" => "no"  ,
        "Yes, use the new profiles (recommended)" => "yes"
    }
                optional ( v13_tcp == "warn" ) {
                    message v13_tcp_warning_1
                    message v13_tcp_warning_2 "USING THE NEW TCP PROFILES MAY SIGNIFICANTLY IMPROVE PERFORMANCE"
                    message v13_tcp_warning_3
                }
                optional ( ssl_encryption_questions.help == "max" ) {
                    message v13_tcp_max "F5 has released new TCP profiles with significantly improved performance. Choose 'Yes' to use these faster profiles. Choose 'No' to use the profiles that were included in previous BIG-IP releases."
                }
            }

            choice client_mode display "xxlarge" default "wan" tcl {

                
                set rval "Local area network  (LAN)\tlan\nWide area network  (WAN)\twan\n"
                if { [tmsh::run_proc f5.iapp.1.5.1.cli:iapp_get_provisioned am] } {
                    append rval "WAN through another BIG-IP system\ttunnel\n"
                }

                return $rval
            }
            optional ( ssl_encryption_questions.help == "max" ) {
                message client_mode_max "Select the type of network that connects the clients to the BIG-IP system. This is used to determine the client-side TCP optimizations the system uses (in the case of WAN or LAN), or if the system will use an iSession tunnel (in the case of WAN through another BIG-IP system)."
            }
            optional ( client_mode == "tunnel" ) {
                message tunnel_max1 "Selecting 'WAN Network through another BIG-IP system' enables this iApp to create a secure and optimized iSession tunnel between this BIG-IP system and the remote BIG-IP system. Note that iSession tunnels are a shared BIG-IP system resource. And once configured, the settings in the iSession profile may overrule certain iApp encryption settings in order to avoid conflicts with the iSession tunnel encryption settings."
                message tunnel_max2 "To use this feature, you must have Local Endpoint and Listener objects created on both BIG-IP systems. See the deployment guide or BIG-IP documentation for information on creating these objects."
            }

            optional ( ssl_encryption_questions.legacy_advanced == "yes"
                    || ssl_encryption_questions.advanced == "yes" ) {
                choice vlan_mode display "xxlarge" default "enabled" {
        "Enable traffic on all VLANs and Tunnels" => "all"  ,
        "Yes, enable traffic only on the VLANs I specify" => "enabled"  ,
        "Yes, disable traffic only on the VLANs I specify" => "disabled"
    }
                optional ( ssl_encryption_questions.help == "max" ) {
                    message vlan_max "You can optionally configure the BIG-IP system to accept or deny client traffic from specific VLANs you have configured. If you leave the default, the BIG-IP system accepts traffic from all VLANs configured on the system. If you select to enable or disable traffic on specific VLANs, you must specify the VLANs in the next question. The VLAN objects must already be configured on this BIG-IP system before you can select them."
                }
                optional ( vlan_mode != "all" ) {
                    multichoice client_vlan default tcl {
                        
                        set ::choices [tmsh::run_proc f5.iapp.1.5.1.cli:iapp_get_items net vlan]
                        return [tmsh::run_proc f5.iapp.1.5.1.cli:iapp_safe_display ::choices]
                    } tcl {
                        
                        set ::choices [tmsh::run_proc f5.iapp.1.5.1.cli:iapp_get_items net vlan]
                        return [tmsh::run_proc f5.iapp.1.5.1.cli:iapp_safe_display ::choices]
                    }
                    optional ( vlan_mode == "disabled" ) {
                        message disabled_vlan_max "By default, all VLANs on the box are in the Selected list.  Because you selected to disable client traffic from specific VLANs, if you do not move any of the VLANs to the Options list, traffic will be denied from ALL VLANs, and this configuration will not pass any traffic."
                    }
                    optional ( ssl_encryption_questions.help == "max" ) {
                        message client_vlan_max "Because you selected you want to enable or disable traffic on specific VLANs in the previous question, use this section to specify the VLANs. By default, all VLANs on the BIG-IP system appear in the Selected box. Click any applicable VLANs and then use the Move buttons (<<) and (>>) to adjust list membership. The Selected box lists the VLANs and tunnels that are specifically enabled or disabled."
                    }
                }
            }

            choice server_mode display "xxlarge" default "lan" tcl {

                
                set rval "Local area network  (LAN)\tlan\nWide area network  (WAN)\twan\n"
                if { [tmsh::run_proc f5.iapp.1.5.1.cli:iapp_get_provisioned am] } {
                    append rval "WAN through another BIG-IP system\ttunnel\n"
                }
                return $rval
            }
            optional ( ssl_encryption_questions.help == "max" ) {
                message server_mode_max "Select the type of network that connects the servers to the BIG-IP system. This is used to determine the server-side TCP optimizations the system uses (in the case of WAN or LAN), or if the system will use an iSession tunnel (in the case of WAN through another BIG-IP system)."
            }
            optional ( server_mode == "tunnel" ) {
                message tunnel_max3 "Selecting 'WAN Network through another BIG-IP system' enables this iApp to create a secure and optimized iSession tunnel between this BIG-IP system and the remote BIG-IP system. Note that iSession tunnels are a shared BIG-IP system resource. And once configured, the settings in the iSession profile may overrule certain iApp encryption settings in order to avoid conflicts with the iSession tunnel encryption settings."
                message tunnel_max4 "To use this feature, you must have Local Endpoint and Listener objects created on both BIG-IP systems. See the deployment guide or BIG-IP documentation for information on creating these objects."
            }

            optional ( ssl_encryption_questions.legacy_advanced != "no"
                    || ssl_encryption_questions.advanced == "yes" ) {
                choice same_subnet display "xxlarge" default "no" {
        "BIG-IP virtual server IP and web servers are on different subnets" => "no"  ,
        "BIG-IP virtual server IP and web servers are on the same subnet"   => "yes"
    }


                optional ( ssl_encryption_questions.help == "max" ) {
                    message subnet_1_max "It is important to ensure that responses to client requests made using the BIG-IP virtual server address are returned through the BIG-IP system. If the client receives a response directly from the web server, the connection is dropped. The way the BIG-IP system handles this depends on your network topology."
                    message subnet_2_max "For environments in which the virtual server IP address is on a subnet different from the web servers, select BIG-IP virtual server IP and the web servers are on different subnets."
                    message subnet_3_max "For environments in which the virtual server IP address provided is on the same subnet as the web servers in the associated pool, select BIG-IP virtual server IP and the web servers are on the same subnet. This enables Secure Network Address Translation (SNAT Auto Map). This configuration results in the BIG-IP system replacing the client IP address of an incoming connection with its self IP address  (using floating addresses when available), ensuring the server response returns through the BIG-IP system."
                }

                optional ( same_subnet == "no" ) {
                    choice route_to_bigip display "xxlarge" default "no" {
        "Servers have a route to clients through the BIG-IP system"           => "yes"  ,
        "Servers do not have a route to clients through the BIG-IP system"    => "no"
    }


                    optional ( ssl_encryption_questions.help == "max" ) {
                        message def_rt_1_max "For environments in which the virtual server IP is on a subnet different from the web servers, information regarding the IP setting of the web servers is required to ensure the correct BIG-IP system configuration."
                        message def_rt_2_max "If the web servers use the BIG-IP system as their default gateway, select Web servers have a route for clients through the BIG-IP system. In this scenario, no configuration is needed to support your environment to ensure correct server response handling."
                        message def_rt_3_max "If the web servers do not have a route through the BIG-IP system, select Web servers do not have a route for clients through the BIG-IP system. This enables Secure Network Address Translation  (SNAT Auto Map). This configuration results in the BIG-IP system replacing the client IP address of an incoming connection with its self IP address (using floating addresses when available) ensuring the server response returns through the BIG-IP system. "
                    }
                }

                optional ( same_subnet == "yes"
                         ||  ( same_subnet == "no"
                          && route_to_bigip == "no" )) {
                    choice snat_type display "xxlarge" default "automap" {
                  "Fewer than 64,000 concurrent connections" => "automap"  ,
                  "More than 64,000 concurrent connections" => "snatpool"
    }
                    optional ( ssl_encryption_questions.help == "max" ) {
                        message snat_max "For environments with fewer than 64,000 concurrent connections per server, the BIG-IP system enables SNAT Auto Map, which uses a unique IP:port combination for each client request it sends to the web server. For environments with more than 64,000 concurrent connections per web server, the BIG-IP system enables a SNAT pool, and additional IP addresses are reserved to ensure the system has enough unique combinations. If the system exhausts all combinations, new client connections are refused until one is available."
                    }
                    optional ( snat_type == "snatpool" ) {
                        choice snatpool display "xxlarge" default "/#create_new#" tcl {
                            
                            set ::choices "Create a new SNAT pool\t/#create_new#\n[tmsh::run_proc f5.iapp.1.5.1.cli:iapp_get_items ltm snatpool]"
                            return [tmsh::run_proc f5.iapp.1.5.1.cli:iapp_safe_display ::choices]
                        }
                        optional ( ssl_encryption_questions.help == "max" ) {
                            message snatpool_max "Choose whether you want the iApp template to create a new SNAT Pool for this implementation. If you have already created a custom SNAT Pool, you can select it from the list."
                        }


                        optional ( snatpool == "/#create_new#" ) {
                            table snatpool_members {
                                string addr required validator "IpAddress"
                                    display "xlarge"
                            }


                            optional ( ssl_encryption_questions.help == "max" ) {
                                message snatpool_members_max "Type the IP addresses you want to use for the SNAT Pool.  These addresses should be available IP addresses, not the self IP address(es) of the BIG-IP system."
                            }
                        }

                    }

                }
            }
        }

          optional ( intro.apm_provisioned == "yes" ) {
               section apm {
                    choice use_apm display "xxlarge" default "no" {
               "Yes, provide secure authentication using APM" => "yes"  ,
               "No, do not provide secure authentication using APM" => "no"
          }
                    optional ( ssl_encryption_questions.help == "max" ) {
                         message use_apm_help "If you have fully licensed and provisioned the BIG-IP Access Policy Manager, you have the option of using it to provide proxy authentication and secure remote access for web."
                    }
                    optional ( use_apm == "yes" ) {
                         choice apm_profile display "xxlarge" tcl {
                              
                              set ::choices "[tmsh::run_proc f5.iapp.1.5.1.cli:iapp_get_items -nocomplain apm profile access]"
                              return [tmsh::run_proc f5.iapp.1.5.1.cli:iapp_safe_display ::choices]
                         }
                         optional ( ssl_encryption_questions.help == "max" ) {
                             message apm_profile_help "In order to use BIG-IP APM in this template, you must have manually created an APM Access Profile for your application. Select the Access Profile you created from the list, or exit the template and create an Access Profile manually.  See Access Policy > Access Profiles > Access Profiles List to create a profile. For specific instructions, see the Help tab or the product documentation."
                         }
                         multichoice apm_sub_profiles display "xxlarge" tcl {
                              
                              set ::choices "[tmsh::run_proc f5.iapp.1.5.1.cli:iapp_get_items -nocomplain apm profile eca]\n[tmsh::run_proc f5.iapp.1.5.1.cli:iapp_get_items -nocomplain apm profile remote-desktop]"
                              return [tmsh::run_proc f5.iapp.1.5.1.cli:iapp_safe_display ::choices]
                         }
                         optional ( ssl_encryption_questions.help == "max" ) {
                             message apm_sub_profiles_help "If you have other BIG-IP APM profiles you want to add to the APM configuration, move them from the Options box to the Selected box. Only APM profiles of type eca and remotedesktop are available.  Note that RBA and WebSSO are required profiles and are added by default."
                         }
                         optional ( intro.is_v11_6 == "yes" ) {
                             choice apm_policy display "xxlarge" default "/#do_not_use#" tcl {
                                  
                                  set ::choices "[tmsh::run_proc f5.iapp.1.5.1.cli:iapp_get_items -nocomplain -filter type eq per-rq-policy apm policy]\nDo not use a per-request Access Policy\t/#do_not_use#"
                                  return [tmsh::run_proc f5.iapp.1.5.1.cli:iapp_safe_display ::choices]
                             }
                             optional ( ssl_encryption_questions.help == "max" ) {
                                 message apm_policy_help ""
                             }
                         }
                     }
                 }
             }

        section ssl {

                optional ( apm.use_apm == "no" ) {
                    choice mode display "xxlarge" default "no_ssl" {
        "Terminate SSL from clients, plaintext to servers (SSL offload)"         => "client_ssl"  ,
        "Terminate SSL from clients, re-encrypt to servers (SSL bridging)"
                                                 => "client_ssl_server_ssl"  ,
        "Encrypted traffic is forwarded without decryption (SSL pass-through)"
                                                 => "pass_thru"  ,
        "Plaintext to and from clients, encrypt to servers"         => "server_ssl"  ,
        "Plaintext to and from both clients and servers"            => "no_ssl"
    }
                }
                optional ( apm.use_apm == "yes" ) {
                    choice mode_apm display "xxlarge" default "client_ssl" {
               "Encrypt to clients, plaintext to servers (SSL Offload)"  => "client_ssl"  ,
               "Terminate SSL from clients, re-encrypt to servers (SSL Bridging)"
               => "client_ssl_server_ssl"
          }
                }

            optional ( ssl_encryption_questions.help == "max" ) {
                message mode_1_max "SSL is a cryptographic protocol used to secure client to server communications. Select how you want the BIG-IP system to handle encrypted traffic. For encryption between client and BIG-IP system:"
                message mode_2_max "If your application requires encryption and session persistence (which ensures requests from a single user are always distributed to the server on which they started) , we recommend you configure the BIG-IP system for terminating SSL for client requests. This allows the system to more accurately persist connections based on granular protocol or application-specific variables."
                message mode_3_max "If security requirements do not allow the BIG-IP system to decrypt client connections, select to re-encrypt to the web servers. With this selection the system will use SSL ID or Client/Server IP to enforce session persistence. Because these parameters are less granular, using them may result in inconsistent distribution of client requests."
                message mode_7_max "If you do not want the BIG-IP system to do anything with encrypted traffic and simply send it to the web servers, select SSL pass-through. This differs from SSL re-encryption because the system is not decrypting and re-encrypting the traffic, only sending the traffic through without modification. "
                message mode_4_max "Encryption between BIG-IP system and web servers:"
                message mode_5_max "Encryption and decryption of SSL is computationally intensive and consumes server CPU resources. In environments that do not require encryption between the BIG-IP system and the web servers, select SSL Offload to terminate the SSL session from the client at the BIG-IP system and provide clear text communication from the BIG-IP system to the web servers."
                message mode_6_max "For environments that require encryption between the BIG-IP system and the web servers, select SSL re-encryption to terminate the SSL session from the client at the BIG-IP system and re-encrypt it for communication between the BIG-IP system and the web servers."
            }

            optional ( mode == "client_ssl" || mode == "client_ssl_server_ssl"  || apm.use_apm == "yes"  ) {
                optional ( ssl_encryption_questions.legacy_advanced == "yes"
                        || ssl_encryption_questions.advanced == "yes" ) {
                    choice client_ssl_profile display "xxlarge"
                        default "/#create_new#" tcl {
                        
                        set ::choices "Create a new Client SSL profile\t/#create_new#\n[tmsh::run_proc f5.iapp.1.5.1.cli:iapp_get_items ltm profile client-ssl]"
                        return [tmsh::run_proc f5.iapp.1.5.1.cli:iapp_safe_display ::choices]
                    }
                    optional ( ssl_encryption_questions.help == "max" ) {
                        message client_ssl_profile_max "If you have already created an Client SSL profile that includes the appropriate certificate and key, you can select it from the list.  Otherwise, the iApp creates a new Client SSL profile. "
                    }
                }
                optional (( ssl_encryption_questions.legacy_advanced == "no"
                         && ssl_encryption_questions.advanced == "no" )
                         || client_ssl_profile == "/#create_new#" ) {
                    choice cert default "/Common/default.crt" display "xxlarge" tcl {
                        
                        set ::choices [tmsh::run_proc f5.iapp.1.5.1.cli:iapp_get_items -norecursive -filter NAME !~ ca-bundle.crt|f5-irule.crt sys file ssl-cert]
                        return [tmsh::run_proc f5.iapp.1.5.1.cli:iapp_safe_display ::choices]
                    }
                    optional ( ssl_encryption_questions.help == "max" ) {
                        message cert_max "To establish encrypted communication, a client and server negotiate security parameters that are used for the session. As part of this handshake, a certificate is provided by the server to the client to identify itself. The client can then validate the certificate with an authority for authenticity before sending data. When the BIG-IP system is decrypting communication between the client and server, an SSL certificate and key pair for each fully-qualified DNS name related to this application instance must be configured on the system."
                        message cert1_max "Select the SSL certificate you imported for this deployment.  Importing certificates and keys is not a part of this template, see System > File Management > SSL Certificate List. To select any new certificates and keys you import, you need to restart or reconfigure this template."
                    }
                    choice key default "/Common/default.key" display "xxlarge" tcl {
                        
                        set ::choices [tmsh::run_proc f5.iapp.1.5.1.cli:iapp_get_items -norecursive -filter security-type ne "password" sys file ssl-key]
                        return [tmsh::run_proc f5.iapp.1.5.1.cli:iapp_safe_display ::choices]
                    }
                    optional ( ssl_encryption_questions.help == "max" ) {
                        message key_max "Select the associated SSL key you imported."
                    }
                    optional ( cert == "/Common/default.crt"
                            || key == "/Common/default.key" ) {
                        message ssl_warn_1 "The BIG-IP system's default certificate and key are not secure. For proper security, acquire a certificate and key from a trusted certificate authority, and then import it onto the BIG-IP system."

                    }
                    optional ( ssl_encryption_questions.legacy_advanced == "no"
                         && ssl_encryption_questions.advanced == "no" ) {
                        message ssl_warn_2 "If your key is password-protected, you must build a Client SSL profile outside the iApp, and then identify it in Advanced configuration mode."
                    }

                    optional ( ssl_encryption_questions.legacy_advanced == "yes"
                            || ssl_encryption_questions.advanced == "yes" ) {
                        message ssl_warn_3 "If your key is password-protected, you must manually create a Client SSL profile outside the iApp, and then select it from the list above."
                        choice use_chain_cert display "xxlarge"
                                default "/#do_not_use#" tcl {
                            
                            set ::choices "Do not use an intermediate certificate\t/#do_not_use#\n[tmsh::run_proc f5.iapp.1.5.1.cli:iapp_get_items -norecursive sys file ssl-cert]"
                            return [tmsh::run_proc f5.iapp.1.5.1.cli:iapp_safe_display ::choices]
                        }
                        optional ( ssl_encryption_questions.help == "max" ) {
                            message use_chain_cert_1_max "Intermediate certificates, also called intermediate certificate chains or chain certificates, are used to help systems which depend on SSL certificates for peer identification. These certificates are intended to create a chain of trust between the CA that signed the certificate and the CA that is already trusted by the recipient of the certificate. This allows the recipient to verify the validity of the certificates presented, even when the signing CA is unknown."
                            message use_chain_cert_2_max "Intermediate certificates must be created or imported onto this BIG-IP system prior to running this iApp. See http://support.f5.com/kb/en-us/solutions/public/13000/300/sol13302.html for help on creating an intermediate certificate chain."
                        }
                    }
                }
            }


            optional (( apm.use_apm == "no" &&
                ( ssl.mode == "server_ssl" || ssl.mode == "client_ssl_server_ssl" ))
                || (apm.use_apm == "yes" && ssl.mode_apm == "client_ssl_server_ssl")) {
                choice server_ssl_profile display "xxlarge" default "/#default#" tcl {
                    
                    set ::choices "Create a new Server SSL profile based on serverssl (recommended)\t/#default#\n[tmsh::run_proc f5.iapp.1.5.1.cli:iapp_get_items ltm profile server-ssl]"
                    return [tmsh::run_proc f5.iapp.1.5.1.cli:iapp_safe_display ::choices]
                }
                optional ( ssl_encryption_questions.help == "max" ) {
                    message server_ssl_profile_max "If you have already created an Server SSL profile on this BIG-IP system, you can select it from the list. Otherwise, the iApp creates a new Server SSL profile."
                }
            }
        }

        optional ( intro.asm_provisioned == "yes" && ( ssl.mode != "pass_thru"  )) {
            section asm {
                choice use_asm default "/#do_not_use#" display "xxlarge" tcl {

                    
                    set ::choices "No, do not use Application Security Manager\t/#do_not_use#\nYes, use ASM and create a new ASM policy\t/#create_new#\n[tmsh::run_proc f5.iapp.1.5.1.cli:iapp_get_items -nocomplain -filter controls =~ asm ltm policy]"
                    return [tmsh::run_proc f5.iapp.1.5.1.cli:iapp_safe_display ::choices]
                }
                optional ( ssl_encryption_questions.help == "max" ) {
                    message asm_1_max "Choose whether you want to use BIG-IP ASM to help secure your web deployment. The BIG-IP Application Security Manager (ASM) module is an advanced web application firewall that significantly reduces and mitigates the risk of loss or damage to data, intellectual property, and web applications."
                }
                optional ( asm.use_asm == "/#create_new#" ) {
                    choice asm_template default "POLICY_TEMPLATE_RAPID_DEPLOYMENT" display "xxlarge" tcl {
                    set ::choices "POLICY_TEMPLATE_RAPID_DEPLOYMENT (recommended)\tPOLICY_TEMPLATE_RAPID_DEPLOYMENT\n"
                        return [tmsh::run_proc f5.iapp.1.5.1.cli:iapp_safe_display ::choices]
                    }
                    optional ( ssl_encryption_questions.help == "max" ) {
                        message asm_2_max "Select the template you want the system to use to build the policy.  Note that if you choose to use ASM, the iApp template sets the policy enforcement mode to transparent. In this mode, violations are logged but not blocked. Before changing the mode to blocking, review the log results and adjust the policy for your deployment if necessary."
                    }
                }

                optional ( use_asm != "/#do_not_use#" ) {

                    optional ( intro.is_admin == "yes" ) {
                        choice security_logging default "/#do_not_use#" display "xxlarge" tcl {
                            
                            # Menu should display all log profiles with "network none".
                            # tmsh::run_proc f5.iapp.1.5.1.cli:iapp_get_items will not filter security log profiles,
                            # so the filter has been written inline here.
                            set ::choices "Do not use a logging profile\t/#do_not_use#\n"
                            if { [catch {
                                set profile_list [tmsh::list security log profile all-properties recursive]
                            } err] } {
                                set profile_list " "
                            }
                            array set profiles  [string map {"security log profile" ""} $profile_list]
                            foreach name [array names profiles] {
                                array set subprofile $profiles($name)
                                if { [info exists subprofile(application)] &&  $subprofile(application) != "none" } {
                                    append ::choices "$name\n"
                                }
                            }
                            return [tmsh::run_proc f5.iapp.1.5.1.cli:iapp_safe_display ::choices]
                        }
                        optional ( ssl_encryption_questions.help == "max" ) {
                            message security_logging_max "The logging profile enables you to log detailed information about BIG-IP ASM events and store those logs on the BIG-IP system or a remote logging server (syslog or Splunk). If you want to use a logging profile, we recommend creating one outside this template. Only logging profiles with Application Security enabled appear in the list."
                        }
                    }

                    language_choice language
                    optional ( ssl_encryption_questions.help == "max" ) {
                        message language_max "If using an language encoding other than utf-8, select it from the list."
                    }
                }
            }
        }

        optional ( intro.afm_allowed == "yes" && intro.is_admin == "yes" && intro.is_v11_4 == "yes" ) {
            section afm {
                choice policy default "/#do_not_use#" display "xxlarge" tcl {
                    
                    set ::choices "Yes, use network firewall and IP Intelligence\t/#default#\nNo, do not use network firewall or IP Intelligence\t/#do_not_use#\n[tmsh::run_proc f5.iapp.1.5.1.cli:iapp_get_items -nocomplain security firewall policy]"
                    return [tmsh::run_proc f5.iapp.1.5.1.cli:iapp_safe_display ::choices]
                }
                optional ( ssl_encryption_questions.help == "max" ) {
                    message policy_max "BIG-IP Advanced Firewall Manager (AFM) is a high-performance, stateful, full-proxy network firewall designed to guard data centers against incoming threats that enter the network on the most widely deployed protocols.  BIG-IP AFM must be fully licensed and provisioned to use this functionality. If you have already created an AFM Network Firewall Policy on this BIG-IP system for this implementation, you can select it from the list."
                }
                optional ( policy == "/#default#" ) {

                    choice restrict_by_addr default "/#do_not_use#" display "xxlarge" tcl {
                        
                        set ::choices "No, do not forbid client addresses (allow all)\t/#do_not_use#\nYes, forbid specific client addresses\t/#create_new#\n[tmsh::run_proc f5.iapp.1.5.1.cli:iapp_get_items -nocomplain security firewall address-list]"
                        return [tmsh::run_proc f5.iapp.1.5.1.cli:iapp_safe_display ::choices]
                    }
                    optional ( ssl_encryption_questions.help == "max" ) {
                        message restrict_max "You can use the BIG-IP AFM to restrict access to your application by either IP address or network address. If enabled, the system will only allow access to the virtual server from the address(es) you specify."
                    }
                    optional ( restrict_by_addr == "/#create_new#" ) {
                        string allowed_addr display "xxlarge" required
                        optional ( ssl_encryption_questions.help == "max" ) {
                            message allowed_addr_max "Specify the IP or network address that should have access to the application.  You can use a single IP address, a list of IP addresses separated by spaces, a range of IP addresses separated by a dash (for example 192.0.2.10-192.0.2.100), a single network address, such as 192.0.2.200/24, or any combination of these."
                        }
                    }
                }
                optional ( policy != "/#do_not_use#" ) {
                    choice restrict_by_reputation default "accept" display "xxlarge" tcl {
                        
                        set choices "Accept all connections and log nothing\taccept\nReject connections from IP addresses with poor reputations\treject\nAccept all connections but log those from suspicious networks\twarn"
                        if { [tmsh::run_proc f5.iapp.1.5.1.cli:iapp_tmos_version >= 11.5] } {
                            append choices "\nSelect an IP Intelligence policy\tselect"
                        }
                        return $choices
                    }
                    optional ( ssl_encryption_questions.help == "max" ) {
                        message restrict_by_reputation_max "The BIG-IP AFM uses an IP intelligence database to categorize IP addresses coming into the system. Select the way you want the system to handle possibly malicious networks with a poor reputation score."
                    }
                    optional ( ssl_encryption_questions.help == "max" && restrict_by_reputation != "accept" ) {
                        message restrict_by_reputation_log "By default, IP Intelligence events are logged to Security > Event Logs > Network > IP Intelligence.  For the best performance, F5 recommends creating a remote logging profile to log IP Intelligence events. "
                    }
                    optional ( restrict_by_reputation == "select" ) {
                        choice ip_intelligence_policy display "xxlarge" tcl {
                            
                            set ::choices "[tmsh::run_proc f5.iapp.1.5.1.cli:iapp_get_items -nocomplain security ip-intelligence policy]"
                            return [tmsh::run_proc f5.iapp.1.5.1.cli:iapp_safe_display ::choices]
                        }
                        optional ( ssl_encryption_questions.help == "max" ) {
                            message ip_intelligence_policy_max "Select the custom IP intelligence policy you created for this implementation."
                        }
                    }
                    message restrict_by_reputation_warn "You must have an active IP Intelligence license for IP reputation-based access control to function correctly. "

                    choice staging_policy default "/#do_not_use#" display "xxlarge" tcl {
                        
                        set ::choices "Do not apply a staging policy\t/#do_not_use#\n[tmsh::run_proc f5.iapp.1.5.1.cli:iapp_get_items -nocomplain security firewall policy]"
                        return [tmsh::run_proc f5.iapp.1.5.1.cli:iapp_safe_display ::choices]
                    }
                    message staging_policy1_max "A policy in Staging mode does not block any traffic, and only logs what would be blocked if the policy were placed into production."

                    optional ( ssl_encryption_questions.help == "max" ) {
                        message staging_policy_max "A staged policy allows you to evaluate the effect a policy has on traffic by analyzing the system logs, without actually modifying traffic based on the firewall rules.  You must already have a policy on the system in order to select it from the list.  For specific information on creating a staging policy, see the AFM documentation."
                    }
                    choice security_logging default "/#do_not_use#" display "xxlarge" tcl {

                        # Menu should display all log profiles with "network none".
                        # tmsh::run_proc f5.iapp.1.5.1.cli:iapp_get_items will not filter security log profiles,
                        # so the filter has been written inline here.
                        set ::choices "Do not use a logging profile\t/#do_not_use#\n"
                        if { [catch {
                            set profile_list [tmsh::list security log profile all-properties recursive]
                        } err] } {
                            set profile_list " "
                        }
                        array set profiles \
                            [string map {"security log profile" ""} $profile_list]
                        foreach name [array names profiles] {
                            array set subprofile $profiles($name)
                            if { [info exists subprofile(network)] && \
                                $subprofile(network) != "none" } {
                                append ::choices "$name\n"
                            }
                        }
                        return [tmsh::run_proc f5.iapp.1.5.1.cli:iapp_safe_display ::choices]
                    }
                    optional ( ssl_encryption_questions.help == "max" ) {
                        message security_logging_max "The logging profile enables you to log detailed information about BIG-IP system Network Firewall events and store those logs on the BIG-IP system or a remote logging server (syslog or Splunk). If you want to use a logging profile, we recommend creating one outside this template. Only logging profiles with Network Firewall enabled appear in the list. "
                        message security_logging1_max "If you are also using BIG-IP ASM, and the logging profile you created has both Application Security and Network Firewall enabled in the same profile, you must also select that profile here. See the BIG-IP AFM documentation for specific information on Logging profiles."
                    }
                }
                optional ( ssl_encryption_questions.legacy_advanced == "yes"
                        || ssl_encryption_questions.advanced == "yes" ) {
                    choice dos_security_profile default "/#do_not_use#" display "xxlarge" tcl {
                        
                        set ::choices "Do not use a DoS profile\t/#do_not_use#\n[tmsh::run_proc f5.iapp.1.5.1.cli:iapp_get_items -nocomplain security dos profile]"
                        return [tmsh::run_proc f5.iapp.1.5.1.cli:iapp_safe_display ::choices]
                    }
                    optional ( ssl_encryption_questions.help == "max" ) {
                        message dos_security_profile_max "The Denial-of-Service (DoS) profile can enable Layer 7 application DoS protection of HTTP traffic and Layer 7 DoS protection for SIP and DNS traffic. The iApp template does not create a DoS profile, if you want to use this functionality, you must create a custom DoS Profile outside the template."
                    }
                    choice protocol_security_profile default "/#do_not_use#" display "xxlarge" tcl {
                        
                        set ::choices "Do not use an HTTP protocol security profile\t/#do_not_use#\n[tmsh::run_proc f5.iapp.1.5.1.cli:iapp_get_items -nocomplain security http profile]"
                        return [tmsh::run_proc f5.iapp.1.5.1.cli:iapp_safe_display ::choices]
                    }
                    optional ( ssl_encryption_questions.help == "max" ) {
                        message protocol_security_profile_max "The HTTP protocol security profile consists of many different security checks for the various components of HTTP traffic. The iApp template does not create a HTTP Security profile, if you want to use this functionality, you must create a custom HTTP Security profile outside the template."
                    }
                }
            }
        }
        section pool {
            string addr display "xxlarge" required validator "IpAddress"
            optional ( ssl_encryption_questions.help == "max" ) {
                message addr_max "This IP address, combined with the port you specify below, becomes the BIG-IP virtual server address and port, which clients use to access the application. The system intercepts requests to this IP:Port and distributes them to the web servers."
            }
            optional ( ssl_encryption_questions.legacy_advanced == "yes"
                    || ssl_encryption_questions.advanced == "yes" ) {
                string mask display "xxlarge" validator "IpAddress"
                optional ( ssl_encryption_questions.help == "max" ) {
                    message mask_max "If you specified a network address for the virtual server (allowing the virtual server to handle multiple IP addresses), you must enter the full network mask that represents the address range. If you specified a single address for the virtual server, you may leave this field blank."
                }
            }

            optional ( ssl.mode != "client_ssl" && ssl.mode != "pass_thru"
                && ssl.mode != "client_ssl_server_ssl"  && apm.use_apm == "no" ) {
                string port display "medium" validator "PortNumber"
                    default "80" required
            }
            optional ( ssl.mode == "client_ssl" || ssl.mode == "pass_thru"
                || ssl.mode == "client_ssl_server_ssl"  || apm.use_apm == "yes" ) {
                string port_secure display "medium" validator "PortNumber"
                    default "443" required
            }
            optional ( ssl_encryption_questions.help == "max" ) {
                message port_max "Specify the service port you want to use for the virtual server. The default value displayed here is based your answer to the question asking how the system should handle SSL traffic."
            }

            optional ( ssl_encryption_questions.legacy_advanced == "yes"
                    || ssl_encryption_questions.advanced == "yes" ) {
                optional ( "HIDE" == "THIS" ) {
                    choice is_ha tcl {
                        set sync_status [lindex [tmsh::get_status cm sync-status] 0]
                        set status [tmsh::get_field_value $sync_status status]
                        return $status
                    }
                }

                optional ( is_ha != "Standalone" ) {
                    choice mirror display "xxlarge" default "disabled" {
        "Do not enable connection/persistence mirroring" => "disabled"  ,
        "Enable connection/persistence mirroring"        => "enabled"
    }

                    optional ( ssl_encryption_questions.help == "max" ) {
                        message mirror_max "Connection and persistence mirroring allows you to configure the BIG-IP system to duplicate connection and persistence information to the standby unit of a redundant pair. This setting provides higher reliability, but might affect system performance. For more information, see http://support.f5.com/kb/en-us/solutions/public/13000/400/sol13478.html"
                    }
                }
            }

            table hosts {
                string name required validator "FQDN" display "xlarge"
            }
            optional ( ssl_encryption_questions.help == "max" ) {
                message fqdn_max "Clients can use the FQDN (Fully Qualified Domain Name) you enter here to access the web servers. For each FQDN, your DNS administrator must configure a DNS entry  that resolves to the IP address you entered for the BIG-IP virtual server."
            }

            optional (( ssl_encryption_questions.legacy_advanced == "yes"
                     || ssl_encryption_questions.advanced == "yes" )
                     && ( ssl.mode == "client_ssl"
                     || ssl.mode == "client_ssl_server_ssl"
                     || ssl.mode == "pass_thru"  || apm.use_apm == "yes" )) {

                choice redirect_to_https display "xxlarge" default "yes" {
        "Redirect HTTP to HTTPS"        => "yes"  ,
        "Do not redirect HTTP to HTTPS" => "no"
    }
                optional ( ssl_encryption_questions.help == "max" ) {
                        message redirect_max "It is common for users to mistakenly attempt insecure access  (HTTP)  to a secure application  (HTTPS). The BIG-IP system can automatically redirect these connections to use an encrypted connection."
                    }
                optional ( redirect_to_https == "yes" ) {
                    string redirect_port display "medium"
                        validator "PortNumber" default "80"
                    optional ( ssl_encryption_questions.help == "max" ) {
                        message redirect_port_max "Specify the port from which you want users redirected.  The most common port for HTTP is 80."
                    }
                }
            }

            optional ( ssl_encryption_questions.legacy_advanced == "yes"
                    || ssl_encryption_questions.advanced == "yes" ) {

                optional ( ssl.mode != "pass_thru"  || apm.use_apm == "yes"  ) {
                    choice http display "xxlarge" default "/#create_new#" tcl {
                        
                        set ::choices "Create a new HTTP profile (recommended)\t/#create_new#\n[tmsh::run_proc f5.iapp.1.5.1.cli:iapp_get_items ltm profile http]"
                        return [tmsh::run_proc f5.iapp.1.5.1.cli:iapp_safe_display ::choices]
                    }
                    optional ( ssl_encryption_questions.help == "max" ) {
                        message http_max "The HTTP profile contains settings that tell the BIG-IP system how to handle the HTTP protocol. If you have created a custom HTTP profile for this application, you can select it from the list."
                    }

                    optional ( http == "/#create_new#" ) {
                        choice xff display "xxlarge" default "yes" {
             "Insert X-Forwarded-For HTTP header"        => "yes"  ,
             "Do not insert X-Forwarded-For HTTP header" => "no"
    }
                        optional ( ssl_encryption_questions.help == "max" ) {
                            message xff_max "If you choose to insert the X-Forwarded-For header, the BIG-IP system inserts the original client IP address in the HTTP header for logging purposes. Additional configuration may be required on the web server to log the value of the X-Forwarded-For header."
                        }
                    }
                }

                optional ( ssl.mode != "pass_thru" ) {
                    choice persist display "xxlarge" default "/#cookie#" tcl {
                        
                        if { [tmsh::run_proc f5.iapp.1.5.1.cli:iapp_get_items -exists -local -norecursive ltm persistence cookie /Common/cookie] } {
                            set ::choices "Use cookie persistence (recommended)\t/#cookie#\nUse source address persistence\t/#source#\nDo not use persistence\t/#do_not_use#\n[tmsh::run_proc f5.iapp.1.5.1.cli:iapp_get_items ltm persistence cookie]"
                        } else {
                            set ::choices "Use source address persistence\t/#source#\nDo not use persistence\t/#do_not_use#"
                        }
                        append ::choices "\n[tmsh::run_proc f5.iapp.1.5.1.cli:iapp_get_items ltm persistence source-addr]\n[tmsh::run_proc f5.iapp.1.5.1.cli:iapp_get_items ltm persistence ssl]\n[tmsh::run_proc f5.iapp.1.5.1.cli:iapp_get_items ltm persistence universal]"
                        return [tmsh::run_proc f5.iapp.1.5.1.cli:iapp_safe_display ::choices]
                    }
                }
                optional ( ssl.mode == "pass_thru" ) {
                    choice pass_thru_persist display "xxlarge" default "/#source#" tcl {
                        
                        set ::choices "Use source address persistence\t/#source#\nDo not use persistence\t/#do_not_use#\n[tmsh::run_proc f5.iapp.1.5.1.cli:iapp_get_items ltm persistence source-addr]\n[tmsh::run_proc f5.iapp.1.5.1.cli:iapp_get_items ltm persistence ssl]"
                        return [tmsh::run_proc f5.iapp.1.5.1.cli:iapp_safe_display ::choices]
                    }
                }

                optional ( ssl_encryption_questions.help == "max" && ssl.mode != "pass_thru" ) {
                    message persist_max "With persistence, the BIG-IP system tracks and stores session data, such as the specific pool member that serviced a client request. The F5 recommended method is Cookie persistence, which inserts a cookie in the HTTP header of a client request after an initial load balancing decision is made. The BIG-IP system uses this cookie to direct all subsequent requests from a given client to the same web server in the configured pool.  An alternative method is source address persistence, where the source address of the client is used for persistence. You can also choose not to use persistence, or to select a custom persistence profile you have already created. "
                }
                optional ( ssl_encryption_questions.help == "max" && ssl.mode == "pass_thru" ) {
                        message pass_thru_persist_max "With persistence, the BIG-IP system tracks and stores session data, such as the specific pool member that serviced a client request. For SSL pass-through, the F5 recommended method is source address persistence, where the source address of the client is used for persistence. You can also choose not to use persistence, or to select a custom persistence profile you have already created."
                    }
            }

            optional ( net.server_mode != "tunnel" ) {
                choice pool_to_use display "xxlarge" default "/#create_new#" tcl {
                    
                    set ::choices "Create a new pool\t/#create_new#\nDo not use a pool\t/#do_not_use#\n[tmsh::run_proc f5.iapp.1.5.1.cli:iapp_get_items ltm pool]"
                    return [tmsh::run_proc f5.iapp.1.5.1.cli:iapp_safe_display ::choices]
                }
            }
            optional ( net.server_mode == "tunnel" ) {
                choice pool_to_use_wom display "xxlarge" default "/#do_not_use#" tcl {
                    
                    set ::choices "Create a new pool\t/#create_new#\nDo not use a pool\t/#do_not_use#\n[tmsh::run_proc f5.iapp.1.5.1.cli:iapp_get_items ltm pool]"
                    return [tmsh::run_proc f5.iapp.1.5.1.cli:iapp_safe_display ::choices]
                }
            }


        optional ( ssl_encryption_questions.help == "max" ) {
            message pool_max "A load balancing pool is a logical set of devices, such as web servers, grouped together to receive and process traffic. When clients attempt to access the application via the BIG-IP virtual server, the BIG-IP system distributes requests to any of the servers that are members of that pool."
        }

        optional (( net.server_mode != "tunnel" && pool_to_use == "/#create_new#" )
        || ( net.server_mode == "tunnel" && pool_to_use_wom == "/#create_new#" )) {
            optional ( ssl_encryption_questions.legacy_advanced == "yes"
                    || ssl_encryption_questions.advanced == "yes" ) {
                lb_method lb_method
                optional ( ssl_encryption_questions.help == "max" ) {
                    message lb_method_max "A load balancing method is an algorithm that the BIG-IP system uses to select a pool member for processing a request. F5 recommends the Least Connections load balancing method, where new connections are routed to the node that has the least number of current connections. This is ideal for environments in which pool members have similar performance and capacity capabilities."
                }

                choice use_pga default "no" display "xxlarge" {
                 "Do not use Priority Group Activation (recommended)" => "no"  ,
                 "Use Priority Group Activation"        => "yes"
    }
                optional ( ssl_encryption_questions.help == "max" ) {
                        message pga_max "Priority Group Activation allows you to segment your servers into priority groups.  With Priority Group Activation, the BIG-IP system load balances traffic according to the priority number you assign to the pool members. A higher number indicates higher priority. Traffic is only sent to the servers with the highest priority, unless the number of available servers in that priority group falls below the value you specify as the minimum. The BIG-IP system then sends traffic to the group of servers with the next highest priority, and so on. See the BIG-IP documentation for more details."
                }
                optional ( use_pga == "yes" ) {
                    string min_active_members display "medium" default "0"
                        required validator "NonNegativeNumber"
                        optional ( ssl_encryption_questions.help == "max" ) {
                            message min_active_members_max "Specify the minimum number of servers which must be available before the system sends traffic to servers with a lower priority."
                        }
                    }
            }

            table members {
                editchoice addr display "large" tcl {
                    
                    set ::choices [tmsh::run_proc f5.iapp.1.5.1.cli:iapp_get_items ltm node]
                    return [tmsh::run_proc f5.iapp.1.5.1.cli:iapp_safe_display ::choices]
                }

                optional ( ssl.mode == "client_ssl"
                         || ssl.mode == "no_ssl" ) {
                    string port display "small" required default "80"
                        validator "PortNumber"
                }
                optional ( ssl.mode == "server_ssl"
                         || ssl.mode == "client_ssl_server_ssl"
                         || ssl.mode == "pass_thru" ) {
                    string port_secure display "small" required
                        default "443" validator "PortNumber"
                }


                string connection_limit display "small" required
                        default "0" validator "NonNegativeNumber"
                optional ( lb_method == "ratio-member"
                        || lb_method == "ratio-node"
                        || lb_method == "ratio-session"
                        || lb_method == "ratio-least-connections-member"
                        || lb_method == "ratio-least-connections-node"
                        || lb_method == "dynamic-ratio-member"
                        || lb_method == "dynamic-ratio-node" ) {
                    string ratio default "1" validator "NonNegativeNumber"
                        display "small"
                }

                optional (( ssl_encryption_questions.legacy_advanced == "yes"
                        || ssl_encryption_questions.advanced == "yes" )
                        && use_pga == "yes" ) {
                    string priority default "0" required
                        validator "NonNegativeNumber" display "small"
                }
            }
            optional ( ssl_encryption_questions.help == "max" ) {
                message members_max "Specify the IP address(es) of your web servers. If you have existing nodes on this BIG-IP system, you can select them from the list, otherwise type the addresses. Click Add to include additional servers."
            }
        }
    }

    optional (( ssl_encryption_questions.legacy_advanced == "yes"
            || ssl_encryption_questions.advanced == "yes" )
            || ( ssl.mode != "pass_thru"  || apm.use_apm == "yes"  )) {
        section client {
            optional ( ssl.mode != "pass_thru"  || apm.use_apm == "yes"  ) {
                optional ( intro.am_provisioned == "yes" ) {
                    # If the template user decides to use AAM, the Web
                    # Acceleration question in the Virtual Server  ( basic )
                    # section are modified to disallow "Do not use" as an option.
                    choice use_wa default "yes" display "xxlarge" {
                  "Yes, use BIG-IP AAM (recommended)" => "yes"  ,
                  "No, do not use BIG-IP AAM" => "no"
    }

                    optional ( ssl_encryption_questions.help == "max" && intro.am_provisioned == "yes" ) {
                        message standard_caching_with_wa_max "You can use the BIG-IP Application Acceleration Manager (AAM, formerly WebAccelerator) to accelerate your application traffic."
                    }
                }
                optional ( ssl_encryption_questions.legacy_advanced == "yes"
                        || ssl_encryption_questions.advanced == "yes" ) {
                    # If the template user elects to use AAM in the
                    # preceding section, the user must *not* be presented with
                    # an option for "Do not use a Web Acceleration profile" here.

                    optional ( intro.am_provisioned == "yes"
                             && use_wa == "yes" ) {

                        choice standard_caching_with_wa display "xxlarge"
                                 default "/#create_new#" tcl {
                            
                            set ::choices "Create a profile based on optimized-acceleration (recommended)\t/#create_new#\n[tmsh::run_proc f5.iapp.1.5.1.cli:iapp_get_items -filter applications ne none ltm profile web-acceleration]"
                            return [tmsh::run_proc f5.iapp.1.5.1.cli:iapp_safe_display ::choices]
                        }
                        optional ( standard_caching_with_wa != "/#create_new#" &&
                                ssl_encryption_questions.help == "max" ) {
                            message standard_caching_with_wa_not_default_max "You have selected a BIG-IP AAM enabled Web Acceleration profile with an AAM application already attached, so an AAM application will not be created by this template. If you would rather have this template produce the AAM application, then choose 'Use F5's recommended Web Acceleration profile' above."
                        }

                        optional ( ssl_encryption_questions.help == "max" ) {
                            message about_custom_caching_max_1 "Caching is the local storage of data for re-use. Once an item is cached on the BIG-IP system, subsequent requests for the same data are served from local storage. This can improve client request response times and improve server scalability by reducing load associated with processing subsequent requests."
                        }
                        optional ( ssl_encryption_questions.help == "max" && use_wa == "yes") {
                            message about_custom_caching_max_2 "If you want to select a custom Web Acceleration profile for caching you have already created, it must have an AAM application enabled, otherwise it does not appear in the list of caching profiles. If you want access to all Web Acceleration profiles on the box, then you must choose No to the use BIG-IP AAM question. Use a custom Web Acceleration profile only if you need to define specific URIs that should or should not be cached. "
                        }
                    }

                    optional ( intro.am_provisioned == "no" || use_wa != "yes" ) {
                        choice standard_caching_without_wa display "xxlarge" default "/#create_new#" tcl {
                            
                            set prof_list [tmsh::run_proc f5.iapp.1.5.1.cli:iapp_get_items -filter applications eq none -list ltm profile web-acceleration]
                            set purge_item [lsearch $prof_list "/Common/optimized-acceleration"]
                            if { $purge_item != -1 } {
                                set prof_list [lreplace $prof_list $purge_item $purge_item]
                            }
                            set ::choices "Create a profile based on optimized-caching (recommended)\t/#create_new#\nDo not use caching\t/#do_not_use#\n[join $prof_list \n]"
                            return [tmsh::run_proc f5.iapp.1.5.1.cli:iapp_safe_display ::choices]
                        }
                        optional ( ssl_encryption_questions.help == "max" ) {
                            message about_custom_caching_max_1a "Caching is the local storage of data for re-use. Once an item is cached on the BIG-IP system, subsequent requests for the same data are served from local storage. This can improve client request response times and improve server scalability by reducing load associated with processing subsequent requests."
                            message about_custom_caching_max_3 "Use a custom Web Acceleration profile only if you need to define specific URIs that should or should not be cached."
                        }
                    }
                }

                optional ( intro.am_provisioned == "yes" && ( ssl.mode != "pass_thru"  || apm.use_apm == "yes"  )) {
                    optional ( use_wa == "yes" && (
                               ( ssl_encryption_questions.legacy_advanced == "no"
                               && ssl_encryption_questions.advanced == "no" )
                          || ( ( ssl_encryption_questions.legacy_advanced == "yes"
                               || ssl_encryption_questions.advanced == "yes" )
                             && standard_caching_with_wa == "/#create_new#" )) ) {
                        optional ( ssl_encryption_questions.legacy_advanced == "yes"
                                || ssl_encryption_questions.advanced == "yes" ) {
                            choice x_wa_info_header default "none" display "xxlarge" {
        "Do not insert the header (recommended)"   => "none"  ,
        "Insert the Standard header" => "standard"  ,
        "Insert the Debug header"    => "debug"
    }


                            optional ( ssl_encryption_questions.help == "max" ) {
                                message x_wa_info_max "By default, the AAM X-WA-info header is not included in the response from the BIG-IP system. This header is useful for debugging AAM behavior. If you choose to enable this header, you have two options, Standard and Debug. In Standard mode, the BIG-IP system  inserts an HTTP header that includes numeric codes which indicate if and how each object was cached. In Debug mode, the BIG-IP system includes additional information which may help for extended troubleshooting."
                            }

                            choice enable_perf_monitor display "xxlarge" default "no" {
         "Do not enable the legacy performance monitor (recommended)" => "no"  ,
         "Enable the legacy performance monitor"        => "yes"
    }

                            optional ( ssl_encryption_questions.help == "max" ) {
                                message enable_perf_monitor_max "Enabling the legacy AAM performance monitor can adversely affect system performance. This monitor is primarily used for legacy AAM performance monitoring and debugging purposes. The BIG-IP Dashboard provides performance graphs and statistics related to AAM."
                            }

                            optional ( enable_perf_monitor == "yes" ) {
                                string data_retention_period default "30" required
                                    validator "NonNegativeNumber" display "medium"
                            }

                            optional ( use_wa == "yes" ) {
                                choice policy display "xxlarge"
                                        default "/Common/Generic Policy - Enhanced" tcl {
                                    
                                    set ::choices "/Common/Generic Policy - Complete\n/Common/Generic Policy - Enhanced\n/Common/Generic Policy - Extension Based\n/Common/Generic Policy - Fundamental\n[string map {"\"" ""} [tmsh::run_proc f5.iapp.1.5.1.cli:iapp_get_items -nocomplain -norecursive -filter predefined == no wam policy predefined]]"
                                    return [tmsh::run_proc f5.iapp.1.5.1.cli:iapp_safe_display ::choices]
                                }
                            }


                            optional ( ssl_encryption_questions.help == "max" ) {
                                optional ( policy == "/Common/Generic Policy - Complete" ) {
                                    message policy_complete_about_max "In this predefined acceleration policy, HTML pages are cached and Intelligent Browser Referencing is enabled."
                                }

                                optional ( policy == "/Common/Generic Policy - Enhanced" ) {
                                    message policy_enhanced_about_max "In this predefined acceleration policy, HTML pages are cached and Intelligent Browser Referencing is enabled for includes."
                                }

                                optional ( policy == "/Common/Generic Policy - Extension Based" ) {
                                    message policy_extension_about_max "This predefined acceleration policy is ideal for High Performance policy for Ecommerce applications that use File Extensions instead of mime-types. This application policy is ideal if response-based matching is not required."
                                }

                                optional ( policy == "/Common/Generic Policy - Fundamental" ) {
                                    message policy_fundamental_about_max "In this predefined acceleration policy, HTML pages are always proxied and Intelligent Browser Referencing is disabled."
                                }

                            }
                        }
                    }
                }

                choice http_compression display "xxlarge" default "/#create_new#" tcl {
                    
                    set ::choices "Create a profile based on wan-optimized-compression (recommended)\t/#create_new#\nDo not compress HTTP responses\t/#do_not_use#\n[tmsh::run_proc f5.iapp.1.5.1.cli:iapp_get_items ltm profile http-compression]"
                    return [tmsh::run_proc f5.iapp.1.5.1.cli:iapp_safe_display ::choices]
                }

                optional ( ssl_encryption_questions.help == "max" ) {
                    message comp_max "Compression improves performance and end user experience for Web applications that suffer from WAN latency and throughput bottlenecks. Compression reduces the amount of traffic sent to the client to complete a transaction. "
                    message comp1_max "To select a profile from the list, it must already be present on the BIG-IP system. Creating a custom profile is not a part of this template; see Local Traffic >> Profiles : Services : HTTP Compression to create an HTTP Compression profile. To select any new profiles you create, you need to restart or reconfigure this template."
                }
            }

            optional ( ssl_encryption_questions.legacy_advanced == "yes"
                    || ssl_encryption_questions.advanced == "yes" ) {
                optional ( net.client_mode == "lan" ) {
                    choice tcp_lan_opt display "xxlarge" default "/#create_new#" tcl {
                        
                        set ::choices "Create a profile for LAN optimization (recommended)\t/#create_new#\n[tmsh::run_proc f5.iapp.1.5.1.cli:iapp_get_items ltm profile tcp]"
                        return [tmsh::run_proc f5.iapp.1.5.1.cli:iapp_safe_display ::choices]
                    }
                    optional ( tcp_lan_opt == "/#create_new#" && intro.is_v13_0 == "yes" ) {
                        optional ( net.v13_tcp == "yes" ) {
                            message tcp_lan_note "The iApp will build a client-side TCP profile based on f5-tcp-lan."
                        }
                        optional ( net.v13_tcp != "yes" ) {
                            message legacy_tcp_lan_note "The iApp will build a client-side TCP profile based on tcp-lan-optimized."
                        }
                    }
                }

                optional ( net.client_mode != "lan" ) {
                    choice tcp_wan_opt display "xxlarge" default "/#create_new#" tcl {
                        
                        set ::choices "Create a profile for WAN optimization (recommended)\t/#create_new#\n[tmsh::run_proc f5.iapp.1.5.1.cli:iapp_get_items ltm profile tcp]"
                        return [tmsh::run_proc f5.iapp.1.5.1.cli:iapp_safe_display ::choices]
                    }
                    optional ( tcp_wan_opt == "/#create_new#" && intro.is_v13_0 == "yes" ) {
                        optional ( net.v13_tcp == "yes" ) {
                            message tcp_wan_note "The iApp will build a client-side TCP profile based on f5-tcp-wan."
                        }
                        optional ( net.v13_tcp != "yes" ) {
                            message legacy_tcp_wan_note "The iApp will build a client-side TCP profile based on tcp-wan-optimized."
                        }
                    }
                }

                optional ( ssl_encryption_questions.help == "max" ) {
                    message tcp_max "The client-side TCP profile optimizes the communication between the BIG-IP system and the client by controlling the behavior of the traffic which results in higher transfer rates, improved connection reliability and increased bandwidth efficiency."
                }
                optional ( net.server_mode == "tunnel"
                    && intro.am_provisioned == "yes" ) {
                    choice isession_profile display "xxlarge" default "/Common/isession" tcl {
                        
                        set ::choices "New iSession profile\t/#create_new#\n[tmsh::run_proc f5.iapp.1.5.1.cli:iapp_get_items -nocomplain wom profile isession]"
                        return [tmsh::run_proc f5.iapp.1.5.1.cli:iapp_safe_display ::choices]
                    }
                    optional ( ssl_encryption_questions.help == "max" ) {
                        message isession_profile_max "The iSession profile contains the settings for the secure and optimized tunnel between this BIG-IP system and the remote BIG-IP system. Remember that iSession tunnels are a shared BIG-IP system resource. And once configured, the settings in the iSession profile may overrule certain iApp encryption settings in order to avoid conflicts with the iSession tunnel encryption settings. F5 recommends using the default 'isession' profile, unless you have already created one on this system. The iApp can also create a new iSession profile."
                    }
                    optional ( isession_profile == "/#create_new#" ) {
                        row isession {
                            choice encryption default "disabled" display "small"
                                { "Yes" => "enabled"  , "No" => "disabled" }
                            choice compression default "enabled" display "small"
                                { "Yes" => "enabled"  , "No" => "disabled" }
                            choice deduplication default "enabled" display "small"
                                { "Yes" => "enabled"  , "No" => "disabled" }
                        }
                        optional ( ssl_encryption_questions.help == "max" ) {
                            message isession_max "The three major options of the iSession profile are WAN encryption, Adaptive Compression, and Deduplication.  WAN encryption specifies whether the traffic on the outbound connection is encrypted. Adaptive Compression selects and adjusts the optimal compression algorithm for the current traffic, based on link speed. Deduplication specifies whether the system optimizes traffic using symmetric data deduplication (locating byte patterns that were previously sent over the WAN, and replacing them with references)."
                        }
                    }
                }
            }
        }
    }

    optional ( ssl_encryption_questions.legacy_advanced == "yes"
            || ssl_encryption_questions.advanced == "yes" ) {
        section server {
            optional (  ssl.mode != "pass_thru"  || apm.use_apm == "yes"  ) {
                choice oneconnect display "xxlarge" default "/#create_new#" tcl {
                    
                    set ::choices "Create a profile based on the oneconnect parent (recommended)\t/#create_new#\nDo not use OneConnect\t/#do_not_use#\n[tmsh::run_proc f5.iapp.1.5.1.cli:iapp_get_items ltm profile one-connect]"
                    return [tmsh::run_proc f5.iapp.1.5.1.cli:iapp_safe_display ::choices]
                }

                optional ( ssl_encryption_questions.help == "max" ) {
                    message oc_max "OneConnect  (connection pooling or multiplexing)  improves server scalability by reducing load associated with concurrent connections and connection rate to web servers. When enabled, the BIG-IP system maintains one connection to each web server which is used to send requests from multiple clients."
                }

            optional ( oneconnect != "/#do_not_use#" ) {
                choice ntlm display "xxlarge" default "/#do_not_use#" tcl {
                    
                    set ::choices "Create an NTLM profile\t/#create_new#\nDo not use NTLM  (recommended)\t/#do_not_use#\n[tmsh::run_proc f5.iapp.1.5.1.cli:iapp_get_items ltm profile ntlm]"
                    return [tmsh::run_proc f5.iapp.1.5.1.cli:iapp_safe_display ::choices]
                }
                optional ( ssl_encryption_questions.help == "max" ) {
                    message ntlm_max "In environments that use the NTLM security protocol with OneConnect, an NTLM profile is also required. This profile ensures a connection between the BIG-IP system and an application server is established and reused on a per-user basis, eliminating the possibility that user data is incorrectly accessible."
                }
            }

            }

            optional ( net.server_mode == "lan" ) {
                choice tcp_lan_opt display "xxlarge" default "/#create_new#" tcl {
                    
                    set ::choices "Create a profile for LAN optimization (recommended)\t/#create_new#\n[tmsh::run_proc f5.iapp.1.5.1.cli:iapp_get_items ltm profile tcp]"
                    return [tmsh::run_proc f5.iapp.1.5.1.cli:iapp_safe_display ::choices]
                }
                optional ( tcp_lan_opt == "/#create_new#" && intro.is_v13_0 == "yes" ) {
                    optional ( net.v13_tcp == "yes" ) {
                        message tcp_lan_note "The iApp will build a server-side TCP profile based on f5-tcp-lan."
                    }
                    optional ( net.v13_tcp != "yes" ) {
                        message legacy_tcp_lan_note "The iApp will build a server-side TCP profile based on tcp-lan-optimized."
                    }
                }
            }

            optional ( net.server_mode != "lan" ) {
                choice tcp_wan_opt display "xxlarge" default "/#create_new#" tcl {
                    
                    set ::choices "Create a profile for WAN optimization (recommended)\t/#create_new#\n[tmsh::run_proc f5.iapp.1.5.1.cli:iapp_get_items ltm profile tcp]"
                    return [tmsh::run_proc f5.iapp.1.5.1.cli:iapp_safe_display ::choices]
                }
                optional ( tcp_wan_opt == "/#create_new#" && intro.is_v13_0 == "yes" ) {
                    optional ( net.v13_tcp == "yes" ) {
                        message tcp_wan_note "The iApp will build a server-side TCP profile based on f5-tcp-wan."
                    }
                    optional ( net.v13_tcp != "yes" ) {
                        message legacy_tcp_wan_note "The iApp will build a server-side TCP profile based on tcp-wan-optimized."
                    }
                }
            }

            optional ( ssl_encryption_questions.help == "max" ) {
                message tcp_max "The server-side TCP profile optimizes the communication between the BIG-IP system and the server by controlling the behavior of the traffic which results in higher transfer rates, improved connection reliability and increased bandwidth efficiency."
            }

            choice tcp_req_queueing display "xxlarge" default "no" {
                        "Yes, enable TCP request queuing" => "yes"  ,
                        "No, do not enable TCP request queuing  (recommended) " => "no"
                    }
            optional ( ssl_encryption_questions.help == "max" ) {
                message tcp_request_queue_2_max "TCP request queuing provides the ability to queue connection requests that exceed the capacity of connections for a pool, pool member, or node, as determined by the connection limit. If you enable TCP request queuing, you must specify a queue length and timeout for queued requests based on server capability, load, and need for shared resources."
            }
            optional ( tcp_req_queueing == "yes" ) {
            message tcp_request_queue_1_max "Improper use or misconfiguration of TCP Request Queuing/Connection Limits can result in unwanted application behavior and poor performance of your BIG-IP system. For this reason we recommended you verify these settings impact prior to deployment in a production environment. You MUST add a Connection Limit to your pool members for TCP Request Queuing."
            string tcp_queue_length display "medium"
                validator "NonNegativeNumber" required
                optional ( ssl_encryption_questions.help == "max" ) {
                    message tcp_queue_length_max "Specify a number for the length of the queue.  You should not use a value of '0', which indicates an unlimited queue length, and is only constrained by available memory."
                }
            string tcp_queue_timeout display "medium"
                validator "NonNegativeNumber" required
                optional ( ssl_encryption_questions.help == "max" ) {
                    message tcp_queue_timeout_max "Specify a number of milliseconds that requests should remain in the queue before timing out."
                }
            }

            optional ( pool.pool_to_use == "/#create_new#" ) {
                choice use_slow_ramp default "yes" display "xxlarge" {
                        "Yes, use Slow Ramp  (recommended) " => "yes"  ,
                        "No, do not use Slow Ramp" => "no"
                    }
                optional ( use_slow_ramp == "yes" ) {
                    optional ( ssl_encryption_questions.help == "max" ) {
                        message slow_ramp_max "With Slow Ramp, the BIG-IP system gradually adds connections to a newly-enabled or newly-added HTTP server over a time period you specify, rather than sending a full proportion of the traffic immediately. Slow Ramp is essential when using load balancing methods like Least Connections, as the BIG-IP system would otherwise send all new connections to a new server immediately, potentially overwhelming that server. The time period you select for Slow Ramp is highly dependent on the speed of your server hardware and the behavior of your web services."
                    }

                    string slow_ramp_setvalue display "medium"
                        default "300" required validator "NonNegativeNumber"
                    optional ( ssl_encryption_questions.help == "max" ) {
                        message slow_ramp_setvalue_max "Specify the duration (in seconds) for Slow Ramp time (the amount of time the system sends less traffic to a newly-enabled pool member). The default setting of 300 seconds  (5 minutes) is very conservative in most cases. "
                    }
                }
            }
        }
    }

    optional (( net.server_mode != "tunnel" && pool.pool_to_use == "/#create_new#" )
    || ( net.server_mode == "tunnel" && pool.pool_to_use_wom == "/#create_new#" )) {
        section monitor {

            choice monitor display "xxlarge" default "/#create_new#" tcl {
                
                set ::choices "Create a new health monitor\t/#create_new#\n[tmsh::run_proc f5.iapp.1.5.1.cli:iapp_get_items ltm monitor http]\n[tmsh::run_proc f5.iapp.1.5.1.cli:iapp_get_items ltm monitor https]\n[tmsh::run_proc f5.iapp.1.5.1.cli:iapp_get_items -filter NAME != "external" ltm monitor external]"
                return [tmsh::run_proc f5.iapp.1.5.1.cli:iapp_safe_display ::choices]
            }

            optional ( ssl_encryption_questions.help == "max" ) {
                message monitor_max "Monitors are used to determine the health of the application on each web server. If an application instance does not respond or responds incorrectly, the system will cease to send client requests to that web server. The system will continue to monitor the instance and will begin sending requests once the application responds correctly."
            }

            optional ( monitor == "/#create_new#" ) {

                optional ( ssl_encryption_questions.legacy_advanced == "yes"
                        || ssl_encryption_questions.advanced == "yes" ) {
                    string frequency display "medium" required default "30"
                    optional ( ssl_encryption_questions.help == "max" ) {
                        message freq_max "This is the duration, in seconds, of a single monitor cycle. At this interval, the system checks the health of the application instance on each web server configured in the web server pool."
                    }
                    choice http_method display "xxlarge" default "GET"
                        { "GET"  , "POST" }
                    optional ( ssl_encryption_questions.help == "max" ) {
                        message method_max "The HTTP request type determines which HTTP method the monitor sends to the web server. GET is the most common request type for web applications."
                    }
                }

                string uri display "xxlarge" required default "/"
                optional ( ssl_encryption_questions.help == "max" ) {
                    message uri_max "The HTTP URI is used to specify the resource on the web server for a given request. This parameter can be customized to request a specific part of an application, which can indicate the health of the application on a granular level."
                }

                optional ( ssl_encryption_questions.legacy_advanced == "yes"
                        || ssl_encryption_questions.advanced == "yes" ) {
                    choice http_version display "xxlarge" default "http11" {
                                "HTTP/1.0" => "http10"  ,
                                "HTTP/1.1" => "http11"
    }

                    optional ( ssl_encryption_questions.help == "max" ) {
                        message version_max "The HTTP version can be customized so it matches what a typical client would be using, in order to detect failures in the most meaningful way. HTTP/1.0 and HTTP/1.1 are the most common.  HTTP/1.0 is more simple, while HTTP/1.1 offers more features."
                    }


                    optional ( http_method == "POST" ) {
                        string post_body display "xxlarge" required

                        optional ( ssl_encryption_questions.help == "max" ) {
                            message body_max "POST requests require an HTTP POST body to send to the web server."
                        }
                    }
                }
                string response display "xxlarge" 
                
                optional ( ssl_encryption_questions.help == "max" ) {
                    message response_max "When the HTTP response arrives for a monitor request, its contents are searched for the value specified here. If it is not found, the monitoring attempt fails."
                }

                optional ( ssl_encryption_questions.legacy_advanced == "yes"
                        || ssl_encryption_questions.advanced == "yes" ) {
                    choice credentials display "xxlarge" default "none" {
         "No, allow anonymous access" => "none"  ,
         "Yes, require credentials for Basic authentication" => "basic"  ,
         "Yes, require credentials for NTLM authentication" => "ntlm"
    }
                    optional ( ssl_encryption_questions.help == "max" ) {
                        message credentials_max "You can configure system to attempt to authenticate to the web implementation as a part of the health monitor. If you choose to require credentials, we recommend you create a user account specifically for this health monitor which has no other privileges, and has a password set to never expire."
                    }
                    optional ( credentials != "none" ) {
                        string user required display "xxlarge"
                        optional ( credentials == "basic" ) {
                            message basic_cred_note "You must include your domain in front of the user name."
                        }
                        optional ( ssl_encryption_questions.help == "max" ) {
                            message user_max "Specify the user name for the account you want to use as a part of the health monitor."
                        }
                        password passwd required display "xxlarge"
                        optional ( ssl_encryption_questions.help == "max" ) {
                            message passwd_max "Specify the associated password. The password for this account should be set to never expire, otherwise servers could be improperly marked as unavailable when the password expires."
                        }
                    }
                }
            }
        }
    }

    optional ( ssl_encryption_questions.legacy_advanced == "yes"
            || ssl_encryption_questions.advanced == "yes" ) {
        section irules {
        message note "Improper use or misconfigurations of an iRule can result in unwanted application behavior and poor performance of your BIG-IP system. For this reason we recommended you verify the impact of an iRule prior to deployment in a production environment."
            optional ( ssl_encryption_questions.help == "max" ) {
                message irule_2_max "The BIG-IP system supports a scripting language to allow an administrator to instruct the system to intercept, inspect, transform, direct and track inbound or outbound application traffic. An iRule contains the set of instructions the system uses to process data flowing through it, either in the header or payload of a packet."
                message irule_3_max "Correct event priority is critical when assigning multiple iRules. For more information about iRule event priority, see https://devcentral.f5.com/wiki/iRules.priority.ashx"
            }

            multichoice irules display "xlarge" tcl {
                
                set ::choices [tmsh::run_proc f5.iapp.1.5.1.cli:iapp_get_items -filter NAME !~ "^_sys" ltm rule]
                return [tmsh::run_proc f5.iapp.1.5.1.cli:iapp_safe_display ::choices]
            }
        }

        optional ( ssl.mode != "pass_thru"  || apm.use_apm == "yes"  ) {
            section stats {
                optional ( intro.analytics_provisioned == "yes" ) {
                    choice analytics display "xxlarge" default "/#do_not_use#" tcl {
                        
                        set ::choices "Do not enable Application Visibility Reporting\t/#do_not_use#\nCreate a profile based on analytics\t/#create_new#\n[tmsh::run_proc f5.iapp.1.5.1.cli:iapp_get_items -nocomplain ltm profile analytics]"
                        return [tmsh::run_proc f5.iapp.1.5.1.cli:iapp_safe_display ::choices]
                    }
                    message avr_1_max "Enabling Analytics may affect overall system performance.  If you choose to enable Analytics, we recommend gathering statistics for a set time period, such as one week, and then re-entering this template and disabling Analytics while you process the data."
                    optional ( ssl_encryption_questions.help == "max" ) {
                        message avr_2_max "The Application Visibility Reporting  (AVR)  module allows you to view statistics specific to your web application. "
                        message avr_3_max "While this template includes a default Analytics profile, for full functionality and flexibility, we recommend you create a custom Analytics profile for this application service. Creating a custom profile is not a part of this template; see Local Traffic >> Profiles : Analytics. Once you have created an Analytics profile, you can select it from the list below. To select any new profiles you create, you need to restart or reconfigure this template."
                    }
                }

                choice request_logging display "xxlarge" default "/#do_not_use#" tcl {
                    
                    set ::choices "Do not enable HTTP request logging\t/#do_not_use#\n[tmsh::run_proc f5.iapp.1.5.1.cli:iapp_get_items ltm profile request-log]"
                    return [tmsh::run_proc f5.iapp.1.5.1.cli:iapp_safe_display ::choices]
                }

                optional ( ssl_encryption_questions.help == "max" ) {
                    message req_log_max "HTTP request logging enables customizable log messages to be sent to a syslog server for each HTTP request processed by this application. Successful usage of this feature requires creation and association of a request logging profile. Creating a request logging profile is not a part of this template. See Local Traffic>>Profiles: Other: Request Logging.  To select any new profiles you create, you need to restart or reconfigure this template. The performance impact of using this feature should be thoroughly tested in a staging environment prior to enabling it on a production deployment."
                }
            }
        }
    }

    optional ( ssl_encryption_questions.help == "max" ) {
        section extra {
            message dns "You must configure a DNS entry for each fully qualified host name that the clients use to access the web servers.  Each DNS record must resolve to the IP address you configured for the BIG-IP virtual server defined in the High Availability section."
            message web_servers "Depending on your web service and application software, you may have to perform additional steps on your web application to enable SSL Offloading. If you are performing SSL offload on the BIG-IP system, you may need to configure your web servers not to expect SSL to avoid redirect loops and needless redirects. Also, the web server software may need to be configured to handle any HTTP/1.1 Host headers you specified during monitor creation."
            optional (( ssl.mode == "client_ssl"
                     || ssl.mode == "client_ssl_server_ssl"  || apm.use_apm == "yes" )
                     && ( ssl.cert == "/Common/default.crt"
                     || ssl.cert == "/Common/ca-bundle.crt"
                     || ssl.cert == "/Common/f5-irule.crt"
                     || ssl.key == "/Common/default.key" )) {
                message critical "You have selected a default BIG-IP certificate and/or key. This application service configuration is incomplete and will not be secure until you import and assign a trusted certificate and key that are valid for all fully qualified domain names used to access the application. See Local Traffic >> SSL Certificate List for importing certificates and keys. To select any new certificates and keys you import, you need to restart or reconfigure this template."
            }
        }
    }
}

optional ( ssl_encryption_questions.offload_ssl == "Yes"
        || ssl_encryption_questions.offload_ssl == "No" ) {
    optional ( intro.analytics_provisioned == "yes" ) {
        section analytics {
            choice add_analytics default "No" display "small" { "Yes" => "Yes"  , "No"  => "No" }
            optional ( add_analytics == "Yes" ) {
                message about_analytics_profiles "For full functionality and flexibility, we recommend that you create a custom Analytics profile for each iApp under Local Traffic > Profiles > Analytics. Once you have created an Analytics profile, you will be able to select it from the list below."
                choice create_new_analytics default "Select a Custom Profile" display "xlarge" {
        "Select a Custom Profile" => "Select a Custom Profile"  ,
        "Use Default Profile" => "Use Default Profile"
    }
                optional ( create_new_analytics == "Select a Custom Profile" ) {
                    choice analytics_profile display "xlarge" tcl {
                        
                        set ::choices [tmsh::run_proc f5.iapp.1.5.1.cli:iapp_get_items -nocomplain ltm profile analytics]
                        return [tmsh::run_proc f5.iapp.1.5.1.cli:iapp_safe_display ::choices]
                    }
                }
            }
        }
    }

    section basic {
        string addr required validator "IpAddress"
        optional ((ssl_encryption_questions.offload_ssl == "Yes"
                && ssl_encryption_questions.offload_ssl_1 == "No" )
                || (ssl_encryption_questions.offload_ssl == "No"
                && ssl_encryption_questions.offload_ssl_2 == "No" )) {
            string port default "80" required validator "PortNumber" display "small"
        }
        optional ((ssl_encryption_questions.offload_ssl == "Yes"
                && ssl_encryption_questions.offload_ssl_1 == "Yes" )
                || (ssl_encryption_questions.offload_ssl == "No"
                && ssl_encryption_questions.offload_ssl_2 == "Yes" )) {
            string secure_port default "443" required validator "PortNumber" display "small"

            choice create_redir default "Yes" display "small" { "Yes" => "Yes"  , "No"  => "No" }
            optional ( create_redir == "Yes" ) {
                string redir_port default "80" required validator "PortNumber" display "small"
            }
        }

        choice snat default "No" display "small" { "Yes" => "Yes"  , "No"  => "No" }
        optional ( snat == "No" ) {
            choice need_snatpool default "No" display "small" { "Yes" => "Yes"  , "No"  => "No" }
            optional ( need_snatpool == "Yes" ) {
                table snatpool_members {
                    string addr required validator "IpAddress"
                }
            }
        }
choice using_ntlm default "No" display "small" { "Yes" => "Yes"  , "No"  => "No" }
    }

    section server_pools {
        choice create_new_pool default "Create New Pool" display "large" {
        "Create New Pool" => "Create New Pool"  ,
        "Use Pool..." => "Use Pool..."
    }
        optional ( create_new_pool == "Create New Pool" ) {
            lb_method lb_method_choice
            table servers {
                string addr required validator "IpAddress"
                string port default "80" required validator "PortNumber"
                    display "small"
                string connection_limit default "0" required
                    validator "NonNegativeNumber" display "small"
                optional ( lb_method_choice == "ratio-member" ||
                           lb_method_choice == "ratio-node" ||
                           lb_method_choice == "ratio-session" ||
                           lb_method_choice == "ratio-least-connections-member" ||
                           lb_method_choice == "ratio-least-connections-node" ||
                           lb_method_choice == "dynamic-ratio-member" ||
                           lb_method_choice == "dynamic-ratio-node" ) {
                    string ratio default "1" validator "NonNegativeNumber"
                        display "small"
                }
            }

            choice tcp_request_queuing_enable_question default "No" display "small" { "Yes" => "Yes"  , "No"  => "No" }
            optional ( tcp_request_queuing_enable_question == "Yes" ) {
                message note "TCP request queuing requires you to have a Connection Limit on your pool members."

                string tcp_request_queue_length required
                    validator "NonNegativeNumber" display "small"
                string tcp_request_queue_timeout required
                    validator "NonNegativeNumber" display "small"
            }

            choice create_new_monitor default "Create New Monitor" display "xlarge" {
        "Create New Monitor" => "Create New Monitor"  ,
        "Use Monitor..." => "Use Monitor..."
    }
            optional ( create_new_monitor == "Create New Monitor" ) {
                string monitor_interval default "30" required
                    validator "NonNegativeNumber" display "small"

                string monitor_send default "GET /" required display "xlarge"

                choice monitor_http_version default "Version 1.0" { "Version 1.0"  , "Version 1.1" }
                optional ( monitor_http_version == "Version 1.1" ) {
                    string monitor_dns_name required validator "FQDN"
                        display "large"
                }

                string monitor_recv display "xlarge"
            }

            optional ( create_new_monitor == "Use Monitor..." ) {
                choice reuse_monitor_name display "xlarge" tcl {
                    
                    set ::choices "[tmsh::run_proc f5.iapp.1.5.1.cli:iapp_get_items ltm monitor http]\n[tmsh::run_proc f5.iapp.1.5.1.cli:iapp_get_items ltm monitor https]"
                    return [tmsh::run_proc f5.iapp.1.5.1.cli:iapp_safe_display ::choices]
                }
            }
        }

        optional ( create_new_pool == "Use Pool..." ) {
            choice reuse_pool_name display "xlarge" tcl {
                
                set ::choices [tmsh::run_proc f5.iapp.1.5.1.cli:iapp_get_items ltm pool]
                return [tmsh::run_proc f5.iapp.1.5.1.cli:iapp_safe_display ::choices]
            }
        }
    }

    section optimizations {
        choice lan_or_wan default "WAN" {
        "WAN" => "WAN"  ,
        "LAN" => "LAN"
    }

        optional ( intro.am_provisioned == "yes" ) {
            choice use_wa default "No" display "small" { "Yes" => "Yes"  , "No"  => "No" }
            optional ( use_wa == "Yes" ) {
                table hosts {
                    string host required validator "FQDN" display "xlarge"
                }

                choice x_wa_info_header default "none" {
        "None" => "none"  ,
        "Standard" => "standard"  ,
        "Debug" => "debug"
    }
                choice perf_monitor default "disabled" {
        "Enabled" => "enabled"  ,
        "Disabled" => "disabled"
    }
                optional ( perf_monitor == "enabled" ) {
                    string data_retention_period default "30" required
                        validator "NonNegativeNumber"
                }

                choice policy display "xlarge"
                        default "/Common/Generic Policy - Enhanced" tcl {
                    
                    set ::choices "/Common/Generic Policy - Complete\n/Common/Generic Policy - Enhanced\n/Common/Generic Policy - Extension Based\n/Common/Generic Policy - Fundamental\n[tmsh::run_proc f5.iapp.1.5.1.cli:iapp_get_items -nocomplain -norecursive -filter predefined == no wam policy predefined]"
                    return [tmsh::run_proc f5.iapp.1.5.1.cli:iapp_safe_display ::choices]
                }
            }
        }

    }
}

text {
    intro "Welcome to the iApp template for web applications"
 intro.early_release "EARLY RELEASE" 
    intro.hello "Introduction" 

    intro.check_for_updates "Check for Updates" 

    intro.am_not_provisioned "Additional features available" 

    intro.analytics_not_provisioned "Additional features available" 

    ssl_encryption_questions "Template Options"

    ssl_encryption_questions.help "Do you want to see inline help?" 

    ssl_encryption_questions.help_max "" 

    ssl_encryption_questions.legacy_advanced "Which configuration mode do you want to use?" 

    ssl_encryption_questions.legacy_warning "NOTE" 

    ssl_encryption_questions.advanced "Which configuration mode do you want to use?" 

    ssl_encryption_questions.conf_mode_max "" 

    net "Network"
    net.v13_tcp "Do you want to use the latest TCP profiles?" 
    net.v13_tcp_warning_1 "" "!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!"
    net.v13_tcp_warning_2 "IMPORTANT" 
    net.v13_tcp_warning_3 "" "!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!"
    net.v13_tcp_max "" 
    net.client_mode "What type of network connects clients to the BIG-IP system?"
    net.client_mode_max "" 
    net.vlan_mode "Do you want to restrict client traffic to specific VLANs?" 

    net.vlan_max "" 

    net.client_vlan "On which VLANs should traffic be enabled or disabled?"

    net.client_vlan_max "" 

    net.disabled_vlan_max "WARNING" 

    net.server_mode "What type of network connects servers to the BIG-IP system?"
    net.server_mode_max "" 

    net.tunnel_max1 "NOTE" 

    net.tunnel_max2 "IMPORTANT" 

    net.tunnel_max3 "NOTE" 

    net.tunnel_max4 "IMPORTANT" 

    net.same_subnet "Where will the virtual servers be in relation to the web servers?" 

    net.subnet_1_max "" 

    net.subnet_2_max "" 

    net.subnet_3_max "" 


    net.route_to_bigip "How have you configured routing on your web servers?" 

    net.def_rt_1_max "" 

    net.def_rt_2_max "" 

    net.def_rt_3_max "" 

    net.snat_type "How many connections do you expect to each web server?" 

    net.snat_max "" 

    net.snatpool "Create a new SNAT pool or use an existing one?"
    net.snatpool_max "" 

    net.snatpool_members "What are the IP addresses you want to use for the SNAT pool?"

    net.snatpool_members.addr "IP"

    net.snatpool_members_max "" 


    ssl "SSL Encryption"

    ssl.mode "How should the BIG-IP system handle SSL traffic?" 

    ssl.mode_1_max "" 

    ssl.mode_2_max "" 

    ssl.mode_3_max "" 

    ssl.mode_4_max "" 

    ssl.mode_5_max "" 

    ssl.mode_6_max "" 

    ssl.mode_7_max "" 

    ssl.cert "Which SSL certificate do you want to use?"
    ssl.cert_max "" 
    ssl.cert1_max "" 

    ssl.key "Which SSL private key do you want to use?"
    ssl.key_max "" 

    ssl.use_chain_cert "Which intermediate certificate do you want to use?"
    ssl.use_chain_cert_1_max "" 

    ssl.use_chain_cert_2_max "" 

    ssl.ssl_warn_1 "WARNING:" 
    ssl.ssl_warn_2 "NOTE:" 
    ssl.ssl_warn_3 "NOTE:" 

    ssl.client_ssl_profile "Which Client SSL profile do you want to use?"
    ssl.client_ssl_profile_max "" 

    ssl.server_ssl_profile "Which Server SSL profile do you want to use?"
    ssl.server_ssl_profile_max "" 

    intro.asm_not_provisioned "Additional features available" 
    asm "Application Security Manager (BIG-IP ASM)"
    asm.use_asm "Do you want to deploy BIG-IP Application Security Manager?"
    asm.asm_template "Which ASM template should be used to build the policy?"
    asm.asm_1_max ""
    asm.asm_2_max ""
    asm.language "Which language encoding is used for ASM?"
    asm.language_max ""
    asm.security_logging "Which logging profile would you like to use?"
    asm.security_logging_max "" 

          apm "Access Policy Manager (BIG-IP APM)"
          apm.use_apm "Provide secure authentication with BIG-IP APM?" 
          apm.use_apm_help ""

          apm.apm_profile "Which Access Profile do you want to use?"
          apm.apm_profile_help ""
          apm.apm_sub_profiles "Which other APM profiles do you want to include? "
          apm.apm_sub_profiles_help ""
          apm.apm_policy "Which Per-Request Access Policy do you want to use?"
          apm.apm_policy_help ""
          ssl.mode_apm "How should the BIG-IP system handle SSL traffic?" 

    afm "Advanced Firewall Manager (BIG-IP AFM)"
    afm.policy "Do you want to use AFM network firewall and IP Intelligence to protect your application?"
    afm.policy_max "" 
    afm.restrict_by_addr "Do you want to forbid access to your application from specific networks or IP addresses?"
    afm.restrict_max "" 
    afm.allowed_addr "What IP or network addresses should be allowed to access your application?"
    afm.allowed_addr_max "" 
    afm.restrict_by_reputation "How should the system control connections from networks suspected of malicious activity?"
    afm.restrict_by_reputation_max "" 
    afm.restrict_by_reputation_log "" 
    afm.restrict_by_reputation_warn "IMPORTANT" 
    afm.ip_intelligence_policy "Which IP Intelligence policy do you want to use?"
    afm.ip_intelligence_policy_max "" 
    afm.staging_policy "Would you like to stage a policy for testing purposes?"
    afm.staging_policy_max "" 
    afm.staging_policy1_max "CRITICAL" 
    afm.security_logging "Which logging profile would you like to use?"
    afm.security_logging_max "" 
    afm.security_logging1_max "" 
    afm.dos_security_profile "Which Denial-of-Service profile do you want to use?"
    afm.dos_security_profile_max "" 
    afm.protocol_security_profile "Which HTTP protocol security profile do you want to use?"
    afm.protocol_security_profile_max "" 

    pool "Virtual Server and Pools"
    pool.addr "What IP address do you want to use for the virtual server?"
    pool.addr_max "" 
    pool.mask "If using a network virtual address, what is the IP mask?"
    pool.mask_max "" 
    pool.port "What port do you want to use for the virtual server?"
    pool.port_max "" 
    pool.mirror "Do you want to enable connection and persistence mirroring?" 
    pool.port_secure "What port do you want to use for the virtual server?"
    pool.hosts "What FQDNs will clients use to access the servers?"
    pool.hosts.name "Host"

    pool.redirect_to_https "Do you want to redirect inbound HTTP traffic to HTTPS?" 

    pool.mirror_max "" 

    pool.redirect_port "From which port should HTTP traffic be redirected?"

    pool.redirect_max "" 

    pool.redirect_port_max "" 


    pool.fqdn_max "" 

    pool.http "Which HTTP profile do you want to use?"
    pool.http_max "" 

    pool.xff "Should the BIG-IP system insert the X-Forwarded-For header?" 

    pool.xff_max "" 

    pool.persist "Which persistence profile do you want to use?"

    pool.pass_thru_persist "Which persistence profile do you want to use?"

    pool.pass_thru_persist_max "" 

    pool.persist_max "" 

    pool.pool_to_use "Do you want to create a new pool or use an existing one?"
    pool.pool_to_use_wom "Do you want to create a new pool or use an existing one?"
    pool.pool_max "" 

    pool.members "Which web servers should be included in this pool?"
    pool.members_max "" 
    pool.members.addr "Node/IP address"
    pool.members.port "Port"
    pool.members.port_secure "Port"
    pool.members.connection_limit "Connection limit"
    pool.members.ratio "Ratio"
    pool.members.priority "Priority"
    pool.lb_method "Which load balancing method do you want to use?"
    pool.lb_method_max "" 

    pool.use_pga "Do you want to give priority to specific groups of servers?" 

    pool.pga_max "" 

    pool.min_active_members "What is the minimum number of active members in a group?"
    pool.min_active_members_max "" 

    client "Delivery Optimization"
    client.use_wa "Use the BIG-IP Application Acceleration Manager?" 
    client.x_wa_info_header "Do you want to insert the X-WA-Info header?" 
    client.x_wa_info_max "" 
    client.enable_perf_monitor "Do you want to use the legacy AAM performance monitor?" 
    client.enable_perf_monitor_max "" 
    client.data_retention_period "For how many days should the BIG-IP system retain the data?"
    client.policy "Which acceleration policy do you want to use?"
    client.policy_complete_about_max "" 
    client.policy_enhanced_about_max "" 
    client.policy_extension_about_max "" 
    client.policy_fundamental_about_max "" 

    client.http_compression "Which compression profile do you want to use?"
    client.standard_caching_with_wa "Which Web Acceleration profile do you want to use for caching?"
    client.standard_caching_with_wa_max "" 
    client.standard_caching_with_wa_not_default_max "" 
    client.standard_caching_without_wa "Which Web Acceleration profile do you want to use for caching?"
    client.about_custom_caching_max_1 "" 
    client.about_custom_caching_max_1a "" 

    client.about_custom_caching_max_2 "" 
    client.about_custom_caching_max_3 "" 

    client.tcp_lan_opt "How do you want to optimize client-side connections?"
    client.tcp_wan_opt "How do you want to optimize client-side connections?"
    client.tcp_lan_note "" 
    client.tcp_wan_note "" 
    client.legacy_tcp_lan_note "" 
    client.legacy_tcp_wan_note "" 
    client.comp_max "" 
    client.comp1_max "" 

    client.tcp_max "" 

    client.isession_profile "Create a new iSession tunnel profile or use an existing one?"
    client.isession_profile_max "" 

    client.isession "Which iSession features do you want to use?"
    client.isession_max "" 

    client.isession.encryption "WAN encryption"
    client.isession.compression "Adaptive Compression"
    client.isession.deduplication "Deduplication"

        server "Server Offload"
    server.oneconnect "Which OneConnect profile do you want to use?"
    server.oc_max "" 

    server.ntlm "Which NTLM profile do you want to use?"
    server.ntlm_max "" 

    server.tcp_lan_opt "How do you want to optimize server-side connections?"
    server.tcp_wan_opt "How do you want to optimize server-side connections?"
    server.tcp_lan_note "" 
    server.tcp_wan_note "" 
    server.legacy_tcp_lan_note "" 
    server.legacy_tcp_wan_note "" 
    server.tcp_max "" 

    server.tcp_req_queueing "Should the BIG-IP system queue TCP requests?" 

    server.tcp_queue_length "What is the maximum number of TCP requests for the queue?"

    server.tcp_queue_length_max "" 

    server.tcp_queue_timeout "How many milliseconds should requests stay in the queue?"

    server.tcp_queue_timeout_max "" 

    server.tcp_request_queue_1_max "WARNING" 

    server.tcp_request_queue_2_max "" 

    server.use_slow_ramp "Use a Slow Ramp time for newly added servers?" 

    server.slow_ramp_max "" 

    server.slow_ramp_setvalue "How many seconds should Slow Ramp time last?"
    server.slow_ramp_setvalue_max "" 

    monitor "Application Health"
    monitor.monitor_max "" 

    monitor.monitor "Create a new health monitor or use an existing one?"
    monitor.http_method "What type of HTTP request should be sent to the servers?"
    monitor.uri "What HTTP URI should be sent to the servers?"

    monitor.http_version "Which HTTP version do your servers expect clients to use?" 
    monitor.version_max "" 

    monitor.frequency "How many seconds should pass between health checks?"
    monitor.freq_max "" 

    monitor.response "What is the expected response to the HTTP request?"
    monitor.method_max "" 

    monitor.uri_max "" 


    monitor.post_body "What HTTP POST body do you want to use for this monitor?"
    monitor.body_max "" 
    monitor.response_max "" 
    monitor.credentials "Should the health monitor require credentials?" 
    monitor.credentials_max "" 
    monitor.basic_cred_note "NOTE" 
    monitor.user "What user name should the monitor use?"
    monitor.user_max "" 
    monitor.passwd "What is the associated password?"
    monitor.passwd_max "" 

    irules "iRules"
    irules.irules "Do you want to add any custom iRules to this configuration?"
    irules.note "WARNING:" 
    irules.irule_2_max "" 

    irules.irule_3_max "" 

    stats "Statistics and Logging"
    stats.analytics "Do you want to enable Analytics for application statistics?"
    stats.request_logging "Which HTTP request logging profile do you want to use?"
    stats.avr_1_max "IMPORTANT" 
    stats.avr_2_max "" 
    stats.avr_3_max "" 


    stats.req_log_max "" 

    extra "Additional Steps"
    extra.dns "DNS" 
    extra.web_servers "Web servers" 
    extra.critical "Default SSL certificate and key" 


    ssl_encryption_questions.deprecated "PLEASE UPGRADE" 
    ssl_encryption_questions.upgrade "Do you want to upgrade this template?"
        
    ssl_encryption_questions.gap_1 " "
    ssl_encryption_questions.gap_2 " "
    ssl_encryption_questions.section_head "SSL Encryption Questions"
    ssl_encryption_questions.offload_ssl_1 "Do you want the BIG-IP system to offload SSL processing from the web servers?"
        
    ssl_encryption_questions.offload_ssl_2 "Do you want the BIG-IP system to offload SSL processing from the web servers?"
        
    ssl_encryption_questions.cert "Which certificate do you want the BIG-IP system to use to authenticate the server? (You may need to import a certificate before deploying this Template.)"
    ssl_encryption_questions.key "Which key do you want the BIG-IP system to use for encryption? (You may need to import a key before deploying this Template.)"

    analytics "Analytics"
    analytics.add_analytics "Do you want to enable Analytics so that you can view application statistics? (This may affect system performance.)"
        
    analytics.about_analytics_profiles "About creating your own Analytics profiles:" 
    analytics.create_new_analytics "Do you want to use a default Analytics profile or select a custom profile?" 
    analytics.analytics_profile "Which Analytics profile do you want to use?"

    basic "Virtual Server Questions"
    basic.addr "What IP address do you want to use for this virtual server?"
    basic.port "What port do you want to use for this virtual server?"
    basic.secure_port "What port do you want to use for this virtual server?"
    basic.create_redir "Do you want to redirect traffic that comes in as HTTP to HTTPS?"
        
    basic.redir_port "What port do you want to use for the redirect virtual server?"
    basic.snat "Do the web servers have a route back to application clients via this BIG-IP system?"
        
    basic.need_snatpool "Will you have more than 64,000 connections at one time? If so, you will need to enter at least one IP address for each 64,000 connections. "
        
    basic.snatpool_members "Enter IP addresses that can be used for a SNAT pool. Enter one IP address for each 64,000 connections "
    basic.snatpool_members.addr "Address: "

    basic.using_ntlm "Are the web servers configured to use NTLM authentication?"
        


    server_pools "HTTP Server Pool, Load Balancing, and Service Monitor Questions"
    server_pools.create_new_pool "Do you want to create a new pool or use an existing one?" 
    server_pools.lb_method_choice "Which load balancing method do you want to use?"
    server_pools.servers "Which servers do you want this virtual server to reference? (The virtual server will not be available until at least one server is added.)"
    server_pools.servers.addr "Address"
    server_pools.servers.port "Port"
    server_pools.servers.ratio "Ratio"
    server_pools.servers.connection_limit "Connection Limit"
    server_pools.tcp_request_queuing_enable_question "Do you want the BIG-IP system to queue TCP requests?"
        
    server_pools.note "NOTE:" 
    server_pools.tcp_request_queue_length "Specify the TCP request queue length. Choose 0 for unlimited."
    server_pools.tcp_request_queue_timeout "Specify a timeout for TCP request queuing in milliseconds. Choose 0 for unlimited."
    server_pools.reuse_pool_name "Choose a pool from the list of available pools."
    server_pools.create_new_monitor "Do you want to create a new health monitor or use an existing one?" 
    server_pools.monitor_interval "How often (in seconds) do you want the BIG-IP system to check on the health of each web server? "
    server_pools.monitor_send "What HTTP request should be sent to check the health of each web server?"

    server_pools.monitor_http_version "What HTTP version do your web servers expect clients to use?"
        

    server_pools.monitor_dns_name "What fully qualified DNS name are HTTP 1.1 clients expected to use to access the web servers?"
    server_pools.monitor_recv "What string can the BIG-IP system expect to see within the health check response for the server to be considered healthy?"
    server_pools.reuse_monitor_name "Choose a monitor from the list of available monitors."


    optimizations "Protocol Optimization Questions"
    optimizations.lan_or_wan "Will clients be connecting to this virtual server primarily over a LAN or a WAN?" 

    optimizations.use_wa "Do you want to use the BIG-IP AAM module to accelerate your traffic?"
        
    optimizations.hosts "What fully qualified DNS names will your end users use to access the web Virtual Server (e.g., site.f5.com)."
    optimizations.hosts.host "Host"
    optimizations.policy "Select the AAM policy to use."
    optimizations.x_wa_info_header "Do you want to insert the X-WA-Info Header?" 
    optimizations.perf_monitor "Do you want to enable the AAM performance monitor?" 
    optimizations.data_retention_period "How many days to you want to keep AAM performance data?"

}
            }
            role-acl { admin manager resource-admin }
            run-as none
        }
    }
    requires-bigip-version-max none
    requires-bigip-version-min 11.5.0
    requires-modules { }
}
